# 1	PHP

## 1.1	PHP 概述

##### 什么是 PHP

- PHP*（Hypertext Preprocessor，即超文本预处理器）*是一种通用开源脚本语言[^脚本语言]。

##### PHP 适合做什么

- PHP 主要适用于 Web 开发领域。

##### PHP 的优点

- 

##### PHP 的缺点

- 

---

<br>

## 1.2	PHP 基本概念

##### PHP 脚本

- PHP 脚本以 `<?php` 开始，以 `?>` 结束，可以放在文档中的任何位置。
- PHP 脚本在服务器上执行，然后将纯 HTML 结果发送回浏览器。

##### php 文件

- PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码。PHP 文件的默认文件扩展名是 `.php`。

---

<br>

## 1.3	PHP Hello World

##### 例

```php+HTML
<!DOCTYPE html>
<html>
<body>

<h1>My first PHP page</h1>

<?php
echo "Hello World!";
?>

</body>
</html>
```

- 在 Web 服务器的 web 目录中创建 .php 文件即可，服务器将自动解析 php 文件。

---

<br>

# 2	基本语法

## 2.1	PHP 标记

##### 说明

- 当解析一个文件时，PHP 会寻找起始和结束标记，也就是 `<?php` 和 `?>`，这告诉 PHP 开始和停止解析二者之间的代码。
- **该解析方式使得 PHP 可以被嵌入到各种不同的文档中**，而任何起始和结束标记之外的部分都会被 PHP 解析器忽略。

##### PHP 短标记

- 短标记以 `<?` 开始以 `?>` 结束，可以像正常标记一样使用。
- 短标记被默认开启的，但是也可以通过修改配置文件 `short_open_tag php.ini` 禁用。或者在 PHP 安装时使用 --disable-short-tags 配置，将该功能默认禁用。
- 因为短标记可以被禁用，所以建议使用普通标记 (`<?php ?>` 和 `<?= ?>`) 来最大化兼容性。

##### 📌在纯 PHP 代码的文件中不要使用结束标记

- 如果文件内容仅仅包含 PHP 代码，最好在文件末尾删除 PHP 结束标记。这可以避免在 PHP 结束标记之后万一意外加入了空格或者换行符，会导致 PHP 开始输出这些空白。

##### 📌<?php echo 的简写

- `<?php echo` 可以简写为 `<?=`。
- **关闭短标记不会影响到缩写形式 `<?=` **，它总是可用的。

---

<br>

## 2.2	从 HTML 中分离

##### **说明**

- 凡是在一对开始和结束标记之外的内容都会被 PHP 解析器忽略，这使得 PHP 文件可以具备混合内容。 可以使 PHP 嵌入到 HTML 文档中去。
- 但是，**处于条件语句中间时**，此时 PHP 解释器会根据条件判断来决定哪些输出，哪些跳过。

##### 例：使用条件的高级分离

```php+HTML
<?php if ($expression == true): ?>
  This will show if the expression is true.
<?php else: ?>
  Otherwise this will show.
<?php endif; ?>
```

- 上例中 PHP 将跳过条件语句未达成的段落，即使该段落位于 PHP 开始和结束标记之外。

##### 📌更有效率的输出

- 要输出大段文本时，跳出 PHP 解析模式通常比将文本通过 echo 或 print 输出更有效率。

---

<br>

## 2.3	指令分隔符

##### 说明

- PHP 需要在每个语句后用分号结束指令。
- PHP 代码中的结束标记隐含表示了一个分号，因此在一个 PHP 代码段中的最后一行可以不用分号结束。

##### 📌省略文件末尾的结束标记

- 文件末尾的 PHP 代码段结束标记可以省略，有些情况下*（比如使用 include 或者 require 时）*省略掉会更好些。

---

<br>

# 3	数据类型

## 3.0	PHP 数据类型概述

##### PHP 支持 10 种原始数据类型

- **四种标量类型**：
  - bool*（布尔型）*
  - int*（整型）*
  - float*（浮点型，也称作 double*)
  - string*（字符串）*
- **四种复合类型**：
  - array*（数组）*
  - object*（对象）*
  - callable*（可调用）*
  - iterable*（可迭代）*
- **两种特殊类型**：
  - resource*（资源）*
  - NULL*（无类型）*

##### 变量的数据类型

- 变量的类型通常不是由程序员设定的，确切地说，是由 PHP 根据该变量使用的上下文在运行时决定的。
- 变量根据其当时的类型在特定场合下会表现出不同的值。

##### 📌var_dump() 函数

- 如果想查看某个表达式的值和类型，用 `var_dump()` 函数。

##### 📌gettype() 函数

- 如果只是想得到一个易读懂的类型的表达方式用于调试，用 `gettype()` 函数。

##### 📌is_type 函数

- 要检验某个类型，使用 `is_type` 函数

---

<br>

## 3.1	Boolean 布尔类型

忽略

---

<br>

## 3.2	Integer 整型

##### 📌包含下划线的整型

- 从 PHP 7.4.0 开始，整型数值可能会包含下划线 `_`，为了更好的阅读体验，这些下划线在展示的时候，会被 PHP 过滤掉。

---

<br>

## 3.3	Float 浮点类型



---

<br>

## 3.4	String 字符串

##### 说明

- 一个字符串 string 就是由一系列的字符组成，其中每个字符等同于一个字节。这意味着 PHP 只能支持 256 的字符集，因此**不支持 Unicode** 。

##### PHP 字符串的 4 种方式表达形式

- 单引号
- 双引号
- heredoc 语法结构
- nowdoc 语法结构*（自 PHP 5.3.0 起）*

##### 单引号

- 定义一个字符串的最简单的方法是用单引号 `'` 把它包围起来。
- 注意: 不像双引号和 heredoc 语法结构，在单引号字符串中的变量和特殊字符的转义序列将不会被替换。

##### 双引号

- 如果字符串是包围在双引号 `"` 中， PHP 将对一些特殊的字符进行解析

##### Heredoc 结构

- Heredoc 结构就象是没有使用双引号的双引号字符串。

- 在 `<<<` 运算符之后提供一个标识符，然后换行。接下来是字符串 string 本身，最后要用前面定义的标识符作为结束标志。

- 结束时所引用的标识符必须在该行的第一列，而且，标识符的命名也要像其它标签一样遵守 PHP 的规则：只能包含字母、数字和下划线，并且必须以字母和下划线作为开头。

- **例**：

  ```php
  <?php
  $str = <<<EOD
  Example of string
  spanning multiple lines
  using heredoc syntax.
  EOD;
  ```

- 📌**注意**：

  - 在 `heredoc` 结构中单引号不用被转义，但是上文中列出的转义序列还可以使用。变量将被替换，但在 `heredoc` 结构中含有复杂的变量时要格外小心。
  - 结束标识符这行除了可能有一个分号 `;` 外，绝对不能包含其它字符。这意味着标识符不能缩进，分号的前后也不能有任何空白或制表符。更重要的是结束标识符的前面必须是个被本地操作系统认可的换行，比如在 UNIX 和 Mac OS X 系统中是 `\n`，而结束定界符之后也必须紧跟一个换行。
  - 在 PHP 5.3.0 以后，才可以用 `Heredoc` 结构来初始化静态变量和类的属性和常量。

##### Nowdoc 结构

- 就象 `heredoc` 结构类似于双引号字符串，`Nowdoc` 结构是类似于单引号字符串的。
- Nowdoc 结构很像 heredoc 结构，但是 **nowdoc 中不进行解析操作**。这种结构很适合用于嵌入 PHP 代码或其它大段文本而无需对其中的特殊字符进行转义。
- 跟 heredocs 不同，nowdocs 可在任何静态数据上下文中使用，包括属性声明。

##### 📌拼接字符串

- 字符串可以用 `.`*（点）*运算符连接起来，注意 `+`*（加号）*运算符没有这个功能。

---

<br>

## 3.5	数组

##### 说明

- **PHP 中的数组实际上是一个有序映射**。映射是一种把 values 关联到 keys 的类型。此类型在很多方面做了优化，因此可以把它当成真正的数组。  

##### 定义数组

- 可以用 `array()` 来新建一个数组。它接受任意数量用逗号分隔的键值对：

  ```php
  array(  key1 =>  value1,key2 =>  value2, ... ,key_n =>  value_n
  ```

  - 键*（key）*可以是一个整数或字符串。
  - 值*（value）*可以是任意类型的值。

- 📌**注意**：

  - 定义数组时，最后一个数组单元之后的逗号可以省略。但是，**对于多维数组，最好保留最后一个逗号**，这样要添加一个新单元时更方便。
  - 自 5.4 起可以使用短数组定义语法，用 `[]` 替代 `array()`。
  - PHP 数组可以同时含有 integer 和 string 类型的键名，因为 PHP 实际并不区分索引数组和关联数组。

- **例**：

  ```php
  <?php
  $array = array(
      "foo" => "bar",
      "bar" => "foo",
  );
  
  // 自 PHP 5.4 起
  $array = [
      "foo" => "bar",
      "bar" => "foo",
  ];
  ?>
  ```

##### 📌key 的强制类型转换

- 包含有合法整型值的字符串会被转换为整型。*（例如键名 "8" 实际会被储存为 8。但是 "08" 则不会强制转换，因为其不是一个合法的十进制数值）*
- 浮点数也会被转换为整型，并且其小数部分会被舍去。*（例如键名 8.7 实际会被储存为 8）*
- 布尔值也会被转换成整型。即键名 `true` 实际会被储存为 1 而键名 `false` 会被储存为 0。
- Null 会被转换为空字符串，即键名 `null` 实际会被储存为 ""。
- 数组和对象不能被用为键名。坚持这么做会导致警告。

##### 访问和修改数组

- 方括号和花括号都可以用来访问数组单元。

- 通过在方括号内指定键名，可以获取对应的值，并进行修改。

- 可以通过下列形式在数组的最后添加一个新的元素：

  ```php
  <?php
      $array = array()
      $array[] = "new"
  ```

  - 如果给出方括号但没有指定键名，则取当前最大整数索引值，新的键名将是该值加上 1。如果当前还没有整数索引，则键名将为 `0`。

- 📌**注意**：

  - 使用如果数组之前不存在，使用 `$array[key] = value`  的形式会创建一个新的数组。但是，**不推荐这样创建数组**，因为该形式与字符串访问运算符一致，如果存在与 array 同名的字符串，`[]` 会作为 **字符串访问运算符** 使用。
  - 对于字符串形式的键名，访问时必须使用引号。

##### 数组删除

- 通过 `unset()` 函数可以删除数组或数组中指定的键值对，例：

  ```php
  <?php
  $arr = array("Ⅰ" => "one","Ⅱ"=>"two",'Ⅲ'=>'three');
                  
  unset($arr["Ⅰ"]); // This removes the element from the array
  
  unset($arr);    // This deletes the whole array
  ?>
  ```

- 📌**注意**：

  - 数组中的元素被删除后，其最大整数索引的信息会被保留，所以如果使用  `arr[]` 的形式向数组中添加新的值，那么新的值的索引将会是原先存在过的最大整数索引 +1。
  - 删除数组中的元素后，可以使用 `array_values()` 函数重建数字索引。

##### 数组合并

- 可以使用 + 将两个数组合并，例

  ```php
  <?php
  
  $array1 = array('1'=>'one','2'=>'two','3'=>'three');
  $array2 = array('4'=>'four','5'=>'five','6'=>'six');
  
  $arr =  $array1 + $array2;
  
  print_r($arr);
  ```

- 📌**注意**：

  - 如果两个数组相同的键，那么在 + 号前面的数组的相同键的值将保留。

---

<br>

## 3.6	Iterable 可迭代对象

##### 说明

- `Iterable` 是 PHP 7.1 中引入的一个伪类型。它接受任何 `array` 或实现了 `Traversable` 接口的对象。这些类型都能用 `foreach` 迭代， 也可以和生成器里的 yield from 一起使用。

##### 可迭代对象作为函数参数

- 可迭代对象可以作为函数参数类型使用，表示函数需要一组值。*（此时通常和  foreach 一起使用）*

- **例**：

  ```php
  <?php
  
  function foo(iterable $iterable) {
      foreach ($iterable as $value) {
          // ...
      } 
  }
  
  ?>
  ```

##### 可迭代对象作为返回值类型

- 可迭代对象还可以用作返回值类型，表示函数将返回一个可迭代的值。 

---

<br>

## 3.7	Object 对象

##### 转换为对象

- 如果将一个对象转换成对象，它将不会有任何变化[^?1]。
- 如果其它任何类型的值被转换成对象，将会创建一个内置类 `stdClass` 的实例。
- 如果该值为 `null`，则新的实例为空。 
- `array` 转换成 `object` 将使键名成为属性名并具有相对应的值。

---

<br>

## 3.8	Resource 资源类型

##### 说明

- 资源是一种特殊变量，用于保存到外部资源的一个引用。
- 资源通过专门的函数来建立和使用。

##### 释放资源

- 引用计数系统是 Zend 引擎的一部分，可以自动检测到一个资源不再被引用了（和 Java 一样）。这种情况下此资源使用的所有外部资源都会被垃圾回收系统释放。因此，很少需要手工释放内存。
- 📌**注意**: 
  - 持久数据库连接比较特殊，它们不会被垃圾回收系统销毁。

---

<br>

## 3.9	NULL

##### 说明

- **`null`** 值表示一个变量没有值。`NULL` 类型唯一可能的值就是 **`null`**。

##### 在下列情况下一个变量被认为是 null

- 被赋值为 **`null`**。
- 尚未被赋值。
- 被 unset。

##### 📌isset()

- `isset()` 可以用于检测变量是否已设置并且非 NULL。

---

<br>

## 3.10	Callback / Callable 类型（未完成）



---

<br>

## 3.11	类型声明（未完成）



---

<br>

## 3.12	类型转换（未完成）



---

<br>

# 4	变量与常量

## 4.1	变量基础

##### PHP 中的变量

- PHP 中的变量使用一个美元符号 `$` 后面跟变量名来表示，变量名区分大小写。

##### 变量名命名规则

- 变量名遵循与 PHP 中其它的标签相同的命名规则。一个有效的变量名由字母或者下划线 `_` 开头，后面跟上任意数量的字母，数字，或者下划线。
- 📌**注意**：
  - 变量名中的字母指是 a-z，A-Z，以及从 128 位到 255 位（0x80-0xff）的 ASCII 字符。

##### 变量的引用赋值

- 引用赋值即新的变量简单的引用了原始变量。改动新的变量将影响到原始变量，反之亦然。

- **语法**：

  - 将一个 & 符号加到将要赋值的变量前。

  - **例**：

    ```php
    <?php
    $foo = 'Bob';              // 将 'Bob' 赋给 $foo
    $bar = &$foo;              // 通过 $bar 引用 $foo
    $bar = "My name is $bar";  // 修改 $bar 变量
    echo $bar;
    echo $foo;                 // $foo 的值也被修改
    ?>
    ```

##### 📌对变量进行初始化

- 虽然在 PHP 中并不需要初始化变量，但对变量进行初始化是个好习惯。未初始化的变量具有其类型的默认值，这在某些情况下会有问题*（例如把一个文件包含到另一个之中时碰上相同的变量名。 使用未初始化的变量会发出 E_NOTICE 错误，不过在向一个未初始化的数组附加单元时不会。）*
- `isset()` 可以用来检测一个变量是否已被初始化。

---

<br>

## 4.2	变量范围（变量作用域）

##### 什么是变量范围

- 变量范围又称变量作用域，即变量定义的上下文背景（也就是它的生效范围）。

- 大部分的 PHP 变量只有一个单独的范围。这个范围的跨度包含了 include 和 require 引入的文件。例如：

  ```php
  <?php
  $a = 1;
  include 'b.inc';
  ?>
  ```

  - 这里变量 `$a` 将会在包含文件 b.inc 中生效。

##### 全局变量

- PHP 中全局变量在函数中使用时必须声明为 global。

- **例**：

  ```php
  <?php
  $a = 1;
  $b = 2;
  
  function Sum(){
      global $a, $b;
      $b = $a + $b;
  }
  
  Sum();
  
  echo $b;
  ?>
  ```

##### 📌在全局范围内访问变量的第二个办法

- 使用 PHP 预定义的  `$GLOBALS` 数组也可以访问全局变量。

- `$GLOBALS` 是一个关联数组，每一个变量为一个元素，键名对应变量名，值对应变量的内容。

- **例**：

  ```php
  <?php
  $a = 1;
  $b = 2;
  
  function Sum(){
      $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
  }
  
  Sum();
  echo $b;
  
  ?>
  ```

##### 静态变量

- 静态变量仅在函数作用域中定义，但当程序执行离开此作用域时，其值并不丢失。

- **例**：

  ```php
  <?php
      function test(){
      static $a = 0;
      echo $a;
      $a++;}
  ?>
  ```

  - 变量 `$a` 仅在第一次调用 `test()` 函数时被初始化，之后每次调用 `test()` 函数都会输出 ​`$a` 的值并加一。

- **静态变量处理递归函数**：

  - 递归函数是一种调用自己的函数。因为可能会无穷递归下去，所以递归函数必须确保有充分的方法来中止递归。**可以使用静态变量作为终止递归函数的判断依据**。

##### 📌PHP 全局和静态变量的实现原理与导致的问题

- PHP 变量的 `static` 和 `global` 定义是以 **引用** 的方式实现的。在函数域内部用 `global` 语句导入的全局变量实际上是建立了一个到全局变量的引用。

- 因此，这可能会导致意外出现，例如：

  ```php
  <?php
  function test_global_ref() {
      global $obj;
      $new = new stdclass;
      $obj = &$new;
  }
  
  function test_global_noref() {
      global $obj;
      $new = new stdclass;
      $obj = $new;
  }
  
  test_global_ref();
  var_dump($obj);
  
  test_global_noref();
  var_dump($obj);
  ?>
  ```

  - 上例会输出：

    ```php
    NULL object(stdClass)#1 (0) { }
    ```

- 类似的问题也适用于 `static` 语句，当在函数中把一个引用赋值给一个静态变量时，第二次调用这个函数时静态变量的值并没有被记住。

---

<br>

## 4.3	可变变量

##### 说明

- 可变变量获取一个普通变量的值作为这个可变变量的变量名。可变变量的变量名可以动态的设置和使用

##### 语法

1. 定义一个普通变量：

   ```php
   <?php
   $a = 'hello';
   ?>
   ```

2. 定义可变变量：

   ```php
   <?php
   $$a = 'world';
   ?>
   ```

3. 这时，两个变量都被定义了，并且`$a` 的内容是 “hello” 并且 `$hello` 的内容是 “world”：

   ```
   <?php
   echo "$a ${$a}";
   
   echo "$a $hello";
   ?>
   ```

   - `$a ${$a}` 和 `$a $hello` 的结果相同，都是 hello world。

---

<br>

## 4.4	来自 PHP 之外的变量

### 4.4.1	HTML 表单

##### 说明

- 当一个表单提交给 PHP 脚本时，表单中的信息会自动在脚本中可用。

##### 访问 HTML 表单中的 POST 数据

```php+HTML
<form action="foo.php" method="POST">
    Name:  <input type="text" name="username"><br />
    Email: <input type="text" name="email"><br />
    <input type="submit" name="submit" value="Submit me!" />
</form>

<?php
echo $_POST['username'];
echo $_REQUEST['username'];
?>
```

##### 访问 GET 数据

- 访问 GET 数据与 访问 POST 数据类似，不过要用适当的 GET 预定义变量。
- GET 也适用于 QUERY_STRING（URL 中在“?”之后的信息）。（例如 http://www.example.com/test.php?id=3 包含有可用 `$_GET['id']` 来访问的 GET 数据）

##### PHP 自动识别

- 变量名中的点和空格被转换成下划线。*（例如 `<input name="a.b" />`  会被替换成 `$_REQUEST["a_b"]`。）*
- PHP 也会识别表单变量上下文中的数组。因此可以将相关的变量编成组，或者利用此特性从多选输入框中取得值。

---

<br>

### 4.4.2	IMAGE SUBMIT

##### 说明

- 当提交表单时，可以用一幅图像代替标准的提交按钮，例如：

  ```
  <input type="image" src="image.gif" name="sub" />
  ```

  - 当用户点击到图像中的某处时，相应的表单会被传送到服务器，并加上两个变量 sub_x 和 sub_y。

---

<br>

### 4.4.3	HTTP Cookies

##### 说明

- PHP 支持 HTTP cookies。Cookies 是一种在远端浏览器端存储数据并能追踪或识别再次访问的用户的机制。可以用 setcookie() 函数设定 cookies。Cookies 是 HTTP 信息头中的一部分，因此 SetCookie() 函数必须在向浏览器发送任何输出之前调用。*（对于 header() 函数也有同样的限制）*Cookie 数据会在相应的 cookie 数据数组中可用，例如 `$_COOKIE` 和 `$_REQUEST`。

---

<br>

## 4.5	常量

##### 定义常量

- 在PHP 5.3.0 之后的版本中，可以用两种方法： `define()` 函数，或 `const` 关键字来定义一个常量。
- 函数 define() 允许将常量定义为一个表达式，而 const 关键字有一些限制。

##### 使用 define() 函数定义常量

- `define()` 用于在运行时定义一个常量。

##### 使用 const 关键字定义常量

- 使用 const 关键字定义常量时，PHP 5.6 之前只能包含标量数据（boolean，integer，float 和 string）。
- 从 PHP 5.6 开始，可以将常量定义为一个表达式，也可以定义为一个 array。
- 和使用 define() 来定义常量相反的是，使用 const 关键字定义常量必须处于最顶端的作用区域，因为用此方法是在编译时定义的。这就意味着不能在函数内，循环内以及 if 或 try/catch 语句之内用 const 来定义常量。
- 使用 const 关键字定义的常量总是大小写敏感的，而使用 define() 函数定义的常量可能不区分大小写。

##### 获取常量的值

- 可以简单的通过指定其名字来取得常量的值，如果常量名是动态的，也可以用函数 `constant()` 来获取常量的值。用

   `get_defined_constants()` 可以获得所有已定义的常量列表。

##### 常量和变量的不同

- 常量前面没有美元符号 `$`；
- PHP 5.3 之前，常量只能用 define() 函数定义，而不能通过赋值语句；
- 常量可以不用理会变量的作用域而在任何地方定义和访问；
- 常量一旦定义就不能被重新定义或者取消定义；
- 常量的值只能是标量值。从 PHP 5.6 开始可以用 const 关键字来定义数组常量，从 PHP 7 开始也可以用 define() 函数来定义。你可以在常量标量表达式中使用数组（例如 const FOO = array(1,2,3)[0];），但是要求最终的结果必须是一个允许的类型的值。

---

<br>

# 5	表达式与运算符

## 5.1	表达式在 PHP 中的意义

##### 说明

- 表达式是 PHP 最重要的基石。PHP 是一种面向表达式的语言，在 PHP 中，几乎所写的任何东西都是一个表达式。简单但却最精确的定义一个表达式的方式就是“任何有值的东西”。

---

<br>

## 5.2	运算符的优先级（忽略）

---

<br>

## 5.3	算术运算符（忽略）

---

<br>

## 5.4	赋值运算符（忽略）

---

<br>

## 5.5	位运算符（忽略）

---

<br>

## 5.6	比较运算符

##### 比较运算符

| 例          | 名称                       | 结果                                                         |
| :---------- | :------------------------- | :----------------------------------------------------------- |
| `$a == $b`  | 等于                       | **`true`**，如果类型转换后 `$a` 等于 ​`$b`。                  |
| `$a === $b` | 全等                       | **`true`**，如果 `$a` 等于 ​`$b`，并且它们的类型也相同。      |
| `$a != $b`  | 不等                       | **`true`**，如果类型转换后 `$a` 不等于 `$b`。                |
| `$a <> $b`  | 不等                       | **`true`**，如果类型转换后 `$a` 不等于 `$b`。                |
| `$a !== $b` | 不全等                     | **`true`**，如果 `$a` 不等于 ​`$b`，或者它们的类型不同。      |
| `$a < $b`   | 小与                       | **`true`**，如果 `$a` 严格小于 `$b`。                        |
| `$a > $b`   | 大于                       | **`true`**，如果 `$a` 严格大于 `$b`。                        |
| `$a <= $b`  | 小于等于                   | **`true`**，如果 `$a` 小于或者等于 `$b`。                    |
| `$a >= $b`  | 大于等于                   | **`true`**，如果 `$a` 大于或者等于 `$b`。                    |
| `$a <=> $b` | 太空船运算符（组合比较符） | 当`$a`小于、等于、大于 `$b` 时 分别返回一个小于、等于、大于0的 int 值。 |

##### 不同类型之间的比较

| 运算数 1 类型                | 运算数 2 类型                | 结果                                                         |
| :--------------------------- | :--------------------------- | :----------------------------------------------------------- |
| null 或 string               | string                       | 将 **`null`** 转换为 ""，进行数字或词汇比较                  |
| bool 或 null                 | 任何其它类型                 | 转换为 bool，**`false`** < **`true`**                        |
| object                       | object                       | 内置类可以定义自己的比较，不同类不能比较，相同类和数组同样方式比较属性（PHP 4 中），PHP 5 有其自己的[说明](https://www.php.net/manual/zh/language.oop5.object-comparison.php) |
| string、resource、int、float | string、resource、int、float | 将字符串和资源转换成数字，按普通数学比较                     |
| array                        | array                        | 具有较少成员的数组较小，如果运算数 1 中的键不存在于运算数 2 中则数组无法比较，否则挨个值比较（见下例） |
| object                       | 任何其它类型                 | object 总是更大                                              |
| array                        | 任何其它类型                 | array 总是更大                                               |

##### NULL 合并运算符 

- 当 expr1 为 **`null`**，表达式 `(expr1) ?? (expr2)` 等同于 expr2，否则为 expr1。

- **例**：

  ```php
  <?php
  $action = $_POST['action'] ?? 'default';
  
  // 以上例子等同于于以下 if/else 语句
  if (isset($_POST['action'])) {
      $action = $_POST['action'];
  } else {
      $action = 'default';
  }
  
  ?>
  ```

- 📌**注意**：

  - NULL 合并运算符是一个表达式，产生的是表达式结果，而不是变量。 返回引用变量时需要强调这一点。 在返回引用的函数里无法使用这样的语句：`return $foo ?? $bar;`。

##### 📌不要比较浮点数

- 由于浮点数 `float` 的内部表达方式，不应比较两个浮点数是否相等。

---

<br>

## 5.7	错误控制运算符

##### 说明

- PHP 错误控制运算符：`@`。
- 当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉。

##### 📌@ 运算符只对表达式有效

- 由于 `@` 运算符只对表达式有效，简单的说，如果能从某处得到值，就能在它前面加上 `@` 运算符。
- 例如，可以把 `@` 运算符放在变量，函数和 `include` 调用，常量，等等之前。**不能把它放在函数或类的定义之前，也不能用于条件结构例如 `if` 和 `foreach` 等。**

##### 📌不要滥用 @

目前的“@”错误控制运算符前缀甚至使导致脚本终止的严重错误的错误报告也失效。 如果加上错误控制运算符的表达式中出现了错误，脚本将会不提示任何信息直接在那里终止。

---

<br>

## 5.8	执行运算符

##### 说明

- PHP 执行运算符：反引号  `` ` 。
- PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。
- 使用反引号运算符 `` ` 的效果与函数 `shell_exec()` 相同。
- 📌**注意**：
  - 关闭了 `shell_exec()` 时反引号运算符是无效的。
  - 与其它某些语言不同，**反引号不能在双引号字符串中使用**。

---

<br>

## 5.9	逻辑运算符

##### 逻辑运算符

| 例子        | 名称            | 结果                                                      |
| :---------- | :-------------- | :-------------------------------------------------------- |
| `$a and $b` | And（逻辑与）   | **`true`**，如果 $a 和 $b 都为 **`true`**。               |
| `$a or $b`  | Or（逻辑或）    | **`true`**，如果 $a 或 $b 任一为 **`true`**。             |
| `$a xor $b` | Xor（逻辑异或） | **`true`**，如果 $a 或 $b 任一为 **`true`**，但不同时是。 |
| `! $a`      | Not（逻辑非）   | **`true`**，如果 $a 不为 **`true`**。                     |
| `$a && $b`  | And（逻辑与）   | **`true`**，如果 $a 和 $b 都为 **`true`**。               |
| `$a || $b`  | Or（逻辑或）    | **`true`**，如果 $a 或 $b 任一为 **`true`**。             |

---

<br>

# 6	流程控制

## 6.1	分支

##### 📌elseif 与 else if

- `else if` 可以写成 `elseif`

---

<br>

## 6.2	循环

---

<br>

## 6.3	遍历

##### 说明

- `foreach` 语法结构提供了遍历数组的简单方式。`foreach` 仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。

##### 语法

- **形式一**：

  ```php
  foreach (iterable_expression as $value)
      statement
  ```

- **形式二**：

  ```php
  foreach (iterable_expression as $key => $value)
      statement
  ```

---

<br>

## 6.4	跳转

---

<br>

## 6.5	declare（未完成）

---

<br>

## 6.6	include 与 require 

**说明**

- `include` 语句包含并运行指定文件。`require` 和 `include` 几乎完全一样，除了处理失败的方式不同之外。*（`require` 在出错时产生 `E_COMPILE_ERROR` 级别的错误。换句话说将导致脚本中止而 `include` 只产生警告（`E_WARNING`），脚本会继续运行。）*

##### php 解释器查找被包含文件的过程

- 被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照 `include_path` 指定的目录寻找。
- 如果在 `include_path` 下没找到该文件则 `include` 最后才在调用脚本文件所在的目录和当前工作目录下寻找。
- 如果最后仍未找到文件则 include 结构会发出一条警告；require 会发出一个致命错误。
- 📌**注意**：
  - 如果定义了路径——不管是绝对路径（在 Windows 下以盘符或者 \ 开头，在 Unix/Linux 下以 / 开头）还是当前目录的相对路径（以 . 或者 .. 开头）——include_path 都会被完全忽略。

##### 被包含文件可以获得的作用域范围

- 当一个文件被包含时，其中所包含的代码继承了 include 所在行的变量范围。从该处开始，**调用文件在该行处可用的任何变量在被调用的文件中也都可用**。不过，**所有在包含文件中定义的函数和类都具有全局作用域**。

##### 被包含文件的解析过程

- 当一个文件被包含时，语法解析器在目标文件的开头脱离 PHP 模式并进入 HTML 模式，到文件结尾处恢复。*（因此，目标文件中需要作为 PHP 代码执行的任何代码都必须被包括在有效的 PHP 起始和结束标记之中。）*

##### 通过 URL 指定被包含文件

- 如果 “URL include wrappers” 选项在 PHP 中被激活，可以用 URL*（通过 HTTP 或者其它支持的封装协议）*而不是本地文件来指定要被包含的文件。
- 如果目标服务器将目标文件作为 PHP 代码解释，则可以用适用于 HTTP GET 的 URL 请求字符串来向被包括的文件传递变量。严格的说这和包含一个文件并继承父文件的变量空间并不是一回事；该脚本文件实际上已经在远程服务器上运行了，而本地脚本则包括了其结果。

##### 处理返回值

- 在失败时 include 返回 FALSE 并且发出警告。成功时，除非在包含文件中另外给出了返回值，否则返回 1。
- 可以在被包括的文件中使用 return 语句来终止该文件中程序的执行并返回调用它的脚本。
- 可以像普通函数一样获得 include 调用的返回值。*（不过在包含远程文件时却不行，除非远程文件的输出具有合法的 PHP 开始和结束标记）*
- 可以在标记内定义所需的变量，该变量在文件被包含的位置之后就可用了。
- 因为 include 是一个特殊的语言结构，其参数不需要括号。在比较其返回值时要注意。

##### require_once 与 include_once

- `require_once`/`include_once` 语句和 `require`/`include` 语句完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。

---

<br>

# 7	函数

## 7.1	基本语法

##### 函数的内容

- 任何有效的 PHP 代码都有可能出现在函数内部，甚至包括其它函数和类定义。

##### 函数的定义位置

- 除了两种特殊情况（有条件的函数和函数中的函数），函数无需在调用之前被定义。

##### 有条件的函数

```php
<?php

$makefoo = true;

/* 不能在此处调用foo()函数，因为它还不存在。*/

if ($makefoo) {
  function foo()
  {
    echo "I don't exist until program execution reaches me.\n";
  }
}

/* 现在可以安全调用函数 foo()
   因为 $makefoo 值为真 */
if ($makefoo) foo();

?>
```

##### 函数中的函数

```php
<?php
function foo()
{
  function bar()
  {
    echo "I don't exist until foo() is called.\n";
  }
}

/* 现在还不能调用 bar() 函数，因为它还不存在 */

foo();

/* 现在可以调用 bar() 函数了，因为 foo() 函数
   的执行使得 bar() 函数变为已定义的函数 */

bar();

?>
```

##### 函数的作用域

- PHP 中的所有函数和类都具有全局作用域。*（因此可以函数定义在另一个函数的内部，而在这个函数的外部被调用）*

##### 📌PHP 函数的缺点

- PHP 不支持函数重载，也不可能取消定义或者重定义已声明的函数。

---

<br>

## 7.2	函数的参数与返回值

##### 函数的参数

- 支持可变参数列表
- 支持参数默认值

##### 📌通过引用传递参数 

- 默认情况下，函数参数通过值传递（使在函数内部改变参数的值，并不会改变函数外部的值）。如果希望允许函数修改它的参数值，必须通过引用传递参数。

- 如果想要函数的一个参数总是通过引用传递，可以在函数定义中该参数的前面加上符号 `&`：

- **例**：

  ```php
  <?php
  function add_some_extra(&$string)
  {
      $string .= 'and something extra.';
  }
  $str = 'This is a string, ';
  add_some_extra($str);
  echo $str;    // outputs 'This is a string, and something extra.'
  ?>
  ```

##### 函数的返回值

- 值通过使用可选的返回语句返回。可以返回包括数组和对象的任意类型。返回语句会立即中止函数的运行，并且将控制权交回调用该函数的代码行。

---

<br>

## 7.3	可变函数

##### PHP 可变函数

- PHP 支持可变函数。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。
- 📌**注意**：
  - 可变函数不能用于例如 echo，print，unset()，isset()，empty()，include，require 以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。

---

<br>

## 7.4	匿名函数

##### 什么是匿名函数

- 匿名函数（Anonymous functions），也叫闭包函数（closures），PHP 允许临时创建一个没有指定名称的函数。

##### 匿名函数的作用

- 匿名函数常用作回调函数 callable 参数的值。当然，也有其它应用的情况。

##### 匿名函数的实现方式

- 匿名函数目前是通过 Closure 类来实现的。

- **例**：

  ```php
  <?php
  echo preg_replace_callback('~-([a-z])~', function ($match) {
      return strtoupper($match[1]);
  }, 'hello-world');
  // 输出 helloWorld
  ?>
  ```

##### 匿名函数作为变量的值

- 闭包函数也可以作为变量的值来使用。PHP 会自动把此种表达式转换成内置类 Closure 的对象实例。把一个 closure 对象赋值给一个变量的方式与普通变量赋值的语法是一样的，最后也要加上分号 `;`（因为此时整个结构构成了一个表达式）。

- **例**：

  ```php
  <?php
  $greet = function($name)
  {
      printf("Hello %s\r\n", $name);
  };
  
  $greet('World');
  $greet('PHP');
  ?>
  ```

##### 从父作用域继承变量

- **什么是父作用域**：闭包的父作用域是定义该闭包的函数（不一定是调用它的函数）。

- 匿名函数可以从父作用域中继承变量。 任何此类变量都应该用 `use` 语言结构传递进去。（ PHP 7.1 起，不能传入下列变量： superglobals、 $this 或者和参数重名的变量）

- **例**：

  ```php
  <?php
  $message = 'hello';
  
  // 没有 "use"
  $example = function () {
      var_dump($message);
  };
  $example();
  
  // 继承 $message
  $example = function () use ($message) {
      var_dump($message);
  };
  $example();
  
  // Inherited variable's value is from when the function
  // is defined, not when called
  $message = 'world';
  $example();
  
  // Reset message
  $message = 'hello';
  
  // Inherit by-reference
  $example = function () use (&$message) {
      var_dump($message);
  };
  $example();
  
  // The changed value in the parent scope
  // is reflected inside the function call
  $message = 'world';
  $example();
  
  // Closures can also accept regular arguments
  $example = function ($arg) use ($message) {
      var_dump($arg . ' ' . $message);
  };
  $example("hello");
  ?>
  ```

##### 静态匿名函数 

- 匿名函数允许被定义为静态化。这样可以防止当前类自动绑定到它们身上，对象在运行时也可能不会被绑定到它们上面。

- **例**：

  ```php
  <?php
  
  class Foo
  {
      function __construct()
      {
          $func = static function() {
              var_dump($this);
          };
          $func();
      }
  };
  new Foo();
  
  ?>
  ```

---

<br>

## 7.5	箭头函数

##### 什么是箭头函数

- 箭头函数是 PHP 7.4 的新语法，是一种更简洁的匿名函数写法。

**箭头函数的实现原理**

- 匿名函数和箭头函数都是 Closure 类的实现。

##### 箭头函数的基本语法

```php
fn (argument_list) => expr
```

##### 箭头函数与匿名函数的区别

- 箭头函数支持与匿名函数相同的功能，只是其父作用域的变量总是自动的。当表达式中使用的变量是在父作用域中定义的，它将被隐式地按值捕获。

---

<br>

# 8	类和对象

## 8.1	基础

##### 类的定义语法

- 每个类的定义都以关键字 `class` 开头，后面跟着类名和一对花括号，花括号里面包含有类的属性与方法的定义。

- **例**：

  ```php
  <?php
  class SimpleClass{
  	//声明属性  
  	public $var = 'a default value';  
      
  	//声明方法
  	public function displayVar() {    
      	echo $this->var;  
  	}
  }
  ?>
  ```

##### $this

- 当一个方法在类定义内部被调用时，有一个可用的伪变量 `$this`。`$this` 是一个到当前对象的引用。

##### 创建类的实例

- 要创建一个类的实例，必须使用 `new` 关键字。如果在 `new` 之后跟着的是一个包含有类名的字符串 `string`，则该类的一个实例被创建。如果该类属于一个命名空间，则必须使用其完整名称。

- 📌**注意**：

  - 当创建新对象时该对象总是被赋值，除非该对象定义了构造函数并且会在出错时抛出了一个异常。
  - 类应在被实例化之前定义（某些情况下则必须这样）。
  - 如果没有参数要传递给类的构造函数，类名后的括号则可以省略掉。

- **例**：

  ```php
  <?php
      $instance = new SimpleClass();
  	// 也可以这样做：
  	$className = 'SimpleClass';
  
  	$instance = new $className(); 
  	// new SimpleClass()
  ?>
  ```

##### 在类的内部创建对象

- 在类的内部，可以用 `new self` 和 `new parent` 创建新对象。

##### 克隆对象

- 当把一个对象已经创建的实例赋给一个新变量时，新变量会访问同一个实例，就和用该对象赋值一样。*（也和给函数传递入实例时一样）*

- 而如果将一个对象变量赋给另一个变量，将会创建出一个新的实例，即克隆对象。*（与 Java 赋予应用给新的变量名不同，而是创建了一个内容相同的新对象赋予新的变量名）*

- **例**：

  ```php
  <?php
  class SimpleClass{}
  $instance = new SimpleClass();
  
  //克隆对象
  $assigned   =  $instance;
  
  //将对象已经创建的实例赋给新变量
  $reference  = & $instance;
  
  $instance = null;
  
  var_dump($instance);//输出 "null"
  var_dump($reference);//输出 ""null"
  var_dump($assigned);//输出 "object(SimpleClass)#1 (1) { ["var"]=> NULL }"
  ?>
  ```

##### 访问对象的成员

```php
<?php
echo (new DateTime())->format('Y');//输出当前年份
?>
```

##### 属性和方法

- 类的属性和方法存在于不同的命名空间中，这意味着同一个类的属性和方法可以使用同样的名字。

- 在类中访问属性和调用方法使用同样的操作符 `->`。

- **例**：访问类属性与调用类方法

  ```php
  <?php
  class Foo
  {
      public $bar = 'property';
  
      public function bar() {
          return 'method';
      }
  }
  
  $obj = new Foo();
  echo $obj->bar, PHP_EOL;//输出 "property"
  echo$obj->bar(), PHP_EOL;//输出 "method"
  ```

##### 类常量

- 可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。

- **例**：

  ```php
  <?php
  class MyClass
  {
      const constant = 'constant value';
  
      function showConstant() {
          echo  self::constant . "\n";
      }
  }
  
  echo MyClass::constant . "\n";
  
  $classname = "MyClass";
  echo $classname::constant."\n"; // 自 5.3.0 起
  
  $class = new MyClass();
  $class->showConstant();
  
  echo $class::constant."\n"; // 自 PHP 5.3.0 起
  ?>
  ```

##### 通过关键词 `class` 解析类名

- 关键词 `class` 也可用于类名的解析。使用 `ClassName::class` 你可以获取一个字符串，包含了类 `ClassName` 的 **完全限定名称**。这对使用了命名空间的类尤其有用。

- **例**：

  ```php
  <?php
  namespace NS {
      class ClassName {  }
  
  echo ClassName::class;//输出 "NS\ClassName"
      
  }
  ?>
  ```

---

<br>

## 8.2	继承

##### 说明

- 一个类可以在声明中用 `extends` 关键字继承另一个类的方法和属性。被继承的方法和属性可以通过用同样的名字重新声明被覆盖。但是如果父类定义方法时使用了 `final` 关键字，则该方法不可被覆盖。可以通过 parent:: 来访问被覆盖的方法或属性。
- PHP 不支持多重继承，一个类只能继承一个基类。
- 📌**注意**：
  - 使用 `::class` 解析类名操作会在底层编译时进行。这意味着在执行该操作时，类还没有被加载。因此，即使要调用的类不存在，类名也会被展示。在此种场景下，并不会发生错误。*（此时会输出 ”Does\Not\Exist“）*
  - 自 PHP 8.0.0 起，`::class` 关键字也可以对象上使用。与上述情况不同，此时解析将会在运行时进行。此操作的运行结果和 get_class() 函数一致。

##### 类的定义顺序

- 除非使用了自动加载，否则一个类必须在使用之前被定义。如果一个类继承了另一个类，则父类必须在子类之前被声明。此规则适用于类的继承与接口的实现。

##### 例

```php
<?php
class ExtendClass extends SimpleClass
{
    // 同样名称的方法，将会覆盖父类的方法
    function displayVar()
    {
        echo "Extending class\n";
        parent::displayVar();
    }
}

$extended = new ExtendClass();
$extended->displayVar();
?>
```

---

<br>

## 8.3	类的自动加载

##### 类自动加载解决的问题

- 在编写面向对象（OOP） 程序时，很多开发者为每个类新建一个 PHP 文件。 这会带来一个烦恼：每个脚本的开头，都需要包含（include）一个长长的列表（每个类对应的文件）。
- 在 PHP 5 中，已经不再需要这样了。

##### spl_autoload_register() 函数

 `spl_autoload_register()` 函数可以注册任意数量的自动加载器，当使用尚未被定义的类和接口时自动去加载。通过注册自动加载器，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。

##### 例

```php
 <?php
 spl_autoload_register(function ($class_name) {
     require_once $class_name . '.php';
 });
 
 $obj  = new MyClass1();
 $obj2 = new MyClass2();
 ?>
```

---

<br>

## 8.4	构造函数和析构函数

### 8.4.1	构造函数

##### 语法

```php
__construct ($var1 , $var2 ... ,$varn ){
    ...
}
```

##### 继承中的构造函数

- 如果子类中定义了构造函数，则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 `parent::__construct()`。
- 如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。

##### 构造方法可以进行重载

- 与其它方法不同，当 `__construct()` 被与父类 `__construct()` 具有不同参数的方法覆盖时，PHP 不会产生一个 **`E_STRICT`** 错误信息。

##### PHP 构造函数与 Java 构造函数的不同点

- 自 PHP 5.3.3 起，**在命名空间中，与类名同名的方法不再作为构造函数**。不使用命名空间中的类则不受影响。 
- PHP 中的构造函数是一个普通的方法，在对应对象实例化时自动被调用。 因此可以定义任何数量的参数，可以是必选、可以有类型、可以有默认值。

##### 使用 static 方法包装构造[^?1]

- **在 PHP 中每个 `class` 只能有一个构造器**。 然而有些情况下，需要用不同的输入实现不同的方式构造对象。 这种情况下推荐使用 `static` 方法包装构造。

- **例**：

  ```php
  <?php
  class Product {
  
      private ?int $id;
      private ?string $name;
  
      private function __construct(?int $id = null, ?string $name = null) {
          $this->id = $id;
          $this->name = $name;
      }
  
      public static function fromBasicData(int $id, string $name): static {
          $new = new static($id, $name);
          return $new;
      }
  
      public static function fromJson(string $json): static {
          $data = json_decode($json);
          return new static($data['id'], $data['name']);
      }
  
      public static function fromXml(string $xml): static {
          // 此处放置自己的代码逻辑
          $data = convert_xml_to_array($xml);
          $new = new static();
          $new->id = $data['id'];
          $new->name = $data['name'];
          return $new;
      }
  }
  
  $p1 = Product::fromBasicData(5, 'Widget');
  $p2 = Product::fromJson($some_json_string);
  $p3 = Product::fromXml($some_xml_string);
  ```

  - `fromBasicData()` 把所需的全部参数传入构造器，创建对象并返回结果。
  - `fromJson()` 接受 JSON 字符串，，预处理成构造器所需的格式，然后返回新的对象。
  - `fromXml()` 接受 XML 字符串并解析，然后创建一个单纯的对象。 由于参数都是可选的，使得可以忽略所有参数去调用构造器。然后为对象的属性赋值后返回结果。
  - 在以上三个例子中，static 关键词会被翻译成代码所在类的类名。 这个例子中是 Product。

---

<br>

### 8.4.2	析构函数

##### 说明

- PHP 5 引入了析构函数的概念，这类似于其它面向对象的语言，如 C++。析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。

##### 语法

```php
__destruct ( ) : void
```

##### 例

```php
<?php

class MyDestructableClass 
{
    function __construct() {
        print "In constructor\n";
    }

    function __destruct() {
        print "Destroying " . __CLASS__ . "\n";
    }
}

$obj = new MyDestructableClass();
```

##### 继承中的析构函数

- 和构造函数一样，父类的析构函数不会被引擎暗中调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用 `parent::__destruct()`。此外也和构造函数一样，子类如果自己没有定义析构函数则会继承父类的。

##### exit() 与析构函数

- 析构函数即使在使用 `exit()` 终止脚本运行时也会被调用。在析构函数中调用 `exit()` 将会中止其余关闭操作的运行。

---

<br>

## 8.5	可见性（访问控制）

### 8.5.1	属性的可见性

##### 说明

- 类属性的可见性有三种：
  1. 公有 `public`
  2. 受保护 `protect`
  3. 私有 `private`。
- 如果用 `var` 关键字定义，则被视为公有。

---

<br>

### 8.5.2	方法的可见性

##### 说明

- 类方法的可见性有三种：
  1. 公有 `public`
  2. 受保护 `protect`
  3. 私有 `private`。
- 如果没有设置这些关键字，则该方法默认为公有。

---

<br>

### 8.5.3	常量的可见性

##### 说明

- 类常量的可见性有三种：
  1. 公有 `public`
  2. 受保护 `protect`
  3. 私有 `private`。
- 如果没有设置这些关键字，则该方法默认为公有。

---

<br>

### 8.5.4	同一个类的对象之间的访问控制

##### 说明

- 同一个类的对象即使不是同一个实例也可以互相访问对方的私有与受保护成员。这是由于在这些对象的内部具体实现的细节都是已知的。

---

<br>

## 8.6	范围解析操作符 ::

##### 说明

- 范围解析操作符（也可称作 Paamayim Nekudotayim）或者更简单地说是一对冒号 `::`，可以用于访问静态成员，类常量，还可以用于覆盖类中的属性和方法（可以通过 :: 方法父类的方法）。

---

<br>

## 8.7	trait （未完成）



---

<br>

## 8.8	匿名类

##### 说明

- PHP 7 开始支持匿名类。 匿名类可以用于创建一次性的简单对象。

##### 例

```php
<?php

// PHP 7 之前的代码
class Logger
{
    public function log($msg)
    {
        echo $msg;
    }
}

$util->setLogger(new Logger());

// 使用了 PHP 7+ 后的代码
$util->setLogger(new class {
    public function log($msg)
    {
        echo $msg;
    }
});
```

---

<br>

## 8.9	PHP 的重载（未完成）

##### 说明

- PHP所提供的重载（overloading）是指**动态地创建类属性和方法**。这是通过魔术方法（magic methods）来实现的。
- 当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。

##### 📌PHP 的重载与 Java 的反射

- PHP 的重载和 Java 的反射概念很相似。

---

<br>

# 9	命名空间

## 9.0	PHP 命名空间概述

##### 什么是命名空间

- 从广义上来说，命名空间是一种封装事物的方法。在很多地方都可以见到这种抽象概念。例如，在操作系统中目录用来将相关文件分组，对于目录中的文件来说，它就扮演了命名空间的角色。

##### 命名空间的作用

- 具例来说，文件 foo.txt 可以同时在目录 /home/greg 和 /home/other 中存在，但在同一个目录中不能存在两个 foo.txt 文件。另外，在目录 /home/greg 外访问 foo.txt 文件时，我们必须将目录名以及目录分隔符放在文件名之前得到 /home/greg/foo.txt。

##### 命名空间在 PHP 中的作用

- 在 PHP 中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题：
  1. 用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。
  2. 为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。

##### 例——PHP命名空间语法

```php
<?php
namespace my\name; // 参考 "定义命名空间" 小节

class MyClass {}
function myfunction() {}
const MYCONST = 1;

$a = new MyClass;
$c = new \my\name\MyClass; // 参考 "全局空间" 小节

$a = strlen('hi'); // 参考 "使用命名空间：后备全局函数/常量" 小节

$d = namespace\MYCONST; // 参考 "namespace操作符和__NAMESPACE__常量” 小节

$d = __NAMESPACE__ . '\MYCONST';
echo constant($d); // 参考 "命名空间和动态语言特征" 小节
?>
```

---

<br>

## 9.1	定义命名空间



---

<br>

## 9.2	使用命名空间

### 9.2.1	使用当前命名空间

##### 说明

- PHP支持两种抽象的访问当前命名空间内部元素的方法
  1. `__NAMESPACE__` 魔术常量
  2.  `namespace` 关键字。

##### \_\_NAMESPACE\_\_ 魔术常量

- 常量 `__NAMESPACE__` 的值是包含当前命名空间名称的字符串。在全局的，不包括在任何命名空间中的代码，它包含一个空的字符串。

- **例**：

  ```php
  <?php
  namespace MyProject;
  
  echo '"', __NAMESPACE__, '"'; // 输出 "MyProject"
  ?>
  ```

  ```php
  <?php
  
  echo '"', __NAMESPACE__, '"'; // 输出 ""
  ?>
  ```

##### namespace 关键字

- 关键字 `namespace` 可用来显式访问当前命名空间或子命名空间中的元素。它等价于类中的 `self` 操作符。

---

<br>

### 9.2.2	命名空间的解析规则（未完成）

##### PHP 中的三种命名空间名称定义

1. **非限定名称 `Unqualified name`**：名称中不包含命名空间分隔符的标识符，例如 `Foo`。
2. **限定名称 `Qualified name`**：名称中含有命名空间分隔符的标识符，例如 `Foo\Bar`。
3. **完全限定名称 `Fully qualified name`**：名称中包含命名空间分隔符，并以命名空间分隔符开始的标识符，例如 `\Foo\Bar`。 `namespace\Foo` 也是一个完全限定名称。

##### 名称解析遵循的规则

- 对完全限定名称的函数，类和常量的调用在编译时解析。例如 `new \A\B` 解析为类 `A\B`。

- 所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 `A\B\C` 被导入为 `C`，那么对 `C\D\e()` 的调用就会被转换为 `A\B\C\D\e()`。

- 在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 `A\B` 内部调用 `C\D\e()`，则 `C\D\e()` 会被转换为 `A\B\C\D\e()` 。

- 非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 `A\B\C` 导入为C，则 `new C()` 被转换为 `new A\B\C() `。

- 在命名空间内部（例如A\B），对非限定名称的函数调用是在运行时解析的。例如对函数 `foo()` 的调用是这样解析的：

  1. 在当前命名空间中查找名为 `A\B\foo()` 的函数
  2. 尝试查找并调用 *全局(global)* 空间中的函数 `foo()`。

- 在命名空间（例如`A\B`）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。下面是调用 `new C()` 及 `new D\E()` 的解析过程： `new C()` 的解析:

  1. 在当前命名空间中查找`A\B\C`类。
  2. 尝试自动装载类`A\B\C`。

  `new D\E()`的解析:

  1. 在类名称前面加上当前命名空间名称变成：`A\B\D\E`，然后查找该类。
  2. 尝试自动装载类 `A\B\D\E`。

  为了引用全局命名空间中的全局类，必须使用完全限定名称 `new \C()`。

---

<br>

# 10	 错误和异常

## 10.1	错误

##### PHP 错误处理机制

- PHP 遇到一系列内部错误时，会报告出来作为应对。 它可以用来标示不同的情况，可以要求将错误显示出来或记录到日志中。

  每个 PHP 产生的错误都包含了类型。可查看 PHP 错误类型清单，它附带了不同类型行为的简短描述和产生的原因。

##### PHP 错误处理配置

- 当未设置错误处理函数时，PHP 会根据配置处理所有出现的错误。 
- **PHP 错误配置**：php.ini 中 `error_reporting` 的配置或者是运行时调用 `error_reporting()` 控制了哪些错误需要报告，哪些错误需要自动忽略。 *（由于有些错误会在运行用户脚本前就可能出现，所以强烈推荐用配置指令来设置）*
- **开发环境下的错误配置**：在开发环境里为了发现并修复 PHP 产生的问题， 应该总是把 `error_reporting` 设置为 `E_ALL`。
- **生产环境下的错误配置**：
  - 在生产环境里，用户可能为了降低信息的详细程度， 将它设置为类似 E_ALL & ~E_NOTICE & ~E_STRICT & ~E_DEPRECATED， 但很多情况下 E_ALL 也同样适用，这样可以更早地警告潜在问题。
  - display_errors 控制了是否要将错位作为脚本输出的一部分显示。 在生产环境里应该禁用，因为可能包含类似数据库密码这样的敏感信息， 而在开发环境中应该启用，能确保立即报告问题。

##### 错误日志

- PHP 不仅能显示错误，还可以开启 log_errors 指令来记录错误日志。它能根据 error_log 的设置， 记录任意错误到文件或者 syslog。 特别适用于生产环境，用户可以记录发生的错误，并根据这些错误生成报告。

---

<br>

## 10.2	错误处理

### 10.2.1	自定义错误处理器

##### 说明

- 如果 PHP 默认错误处理器还不能满足要求，用户可以通过 `set_error_handler()` 设置自定义错误处理器，可处理很多类型的错误。 
- 虽然有些类型的错误不能通过这种方式处理，但能处理的类型可以用脚本合适的方式处理。*（例如为用户显示自定义错误页面，同时以一种比日志更直接的方式上报错误，比如发送邮件）*

---

<br>

### 10.2.2	PHP 7 错误处理

##### 说明

- PHP 7 改变了大多数错误的报告方式。不同于传统（PHP 5）的错误报告机制，现在大多数错误被作为 Error 异常抛出。
- 这种 Error 异常可以像 Exception 异常一样被第一个匹配的 try / catch 块所捕获。如果没有匹配的 catch 块，则调用异常处理函数（事先通过 set_exception_handler() 注册）进行处理。 如果尚未注册异常处理函数，则按照传统方式处理：被报告为一个致命错误（Fatal Error）。

##### 捕获 Error 异常

- Error 类并非继承自 Exception 类，所以不能用 `catch (Exception $e) { ... }` 来捕获 Error。但是，可以用 `catch (Error $e) { ... }`，或者通过注册异常处理函数（ set_exception_handler()）来捕获 Error。

---

<br>

## 10.3	异常抛出

##### 说明

- PHP 有一个和其他语言相似的异常模型。 在 PHP 里可以 throw 并 catch 异常。 为了捕获潜在的异常，可以将代码包含在 try 块里。 每个 try 都必须有一个相应的 catch 或 finally 代码块。

##### 异常抛出

- 如果抛出异常的函数范围内没有 catch 块，异常会沿调用栈“向上冒泡”， 直到找到匹配的 catch 块。 沿途会执行所有遇到的 finally 块。 在没有设置全局异常处理程序（exception handler）时， 如果调用栈向上都没有遇到匹配的 catch，程序会抛出 fatal 错误并终止执行。
- 抛出的对象必须是 Exception 自身或 Exception的子类。 抛出其他对象会导致 PHP 报 Fatal 错误。

##### catch

- catch 定义了处理抛出异常的方式。 catch 块定义了它能处理的异常/错误的类型，并可以选择将异常赋值到变量中。 （在 PHP 8.0.0 之前的版本中必须要赋值到变量） 如果遇到抛出对象的类型匹配了首个 catch 块的异常或错误，将会处理该对象。
- 可以有多个 catch 子句。
- 从 PHP 7.1.0 起 catch 可以用竖线符（|） 指定多个异常。
- PHP 8.0.0 起，throw 关键词现在开始是一个表达式，可用于任何表达式的场景。 在此之前，它是一个语句，必须独占一行。

##### finally

- finally 代码块可以放在 catch 之后，或者直接代替它。 无论是否抛出了异常，在 try 和 catch 之后、在执行后续代码之前， 放在 finally 里的代码总是会执行。
- 值得注意的是 finally 和 return 语句之间存在相互影响。 如果在 try 或 catch 里遇到 return，仍然会执行 finally 里的代码。 而且，遇到 return 语句时，会先执行 finally 再返回结果。 此外，如果 finally 里也包含了 return 语句，将返回 finally 里的值。

---

<br>

# 11	注解



---

<br>

# 附录

##### 最后编辑时间

- 2021/03/04

##### 环境

- php-7.4.15-Win32-vc15-x64
- PhpStorm 2020.3.2

##### 参考

- [PHP 手册](https://www.php.net/manual/zh/index.php)

##### 相关资料

- 

##### 脚注

[^脚本语言]: 又称扩建的语言，或动态语言，是一种编程语言，用来控制软件应用程序，脚本通常以文本*（如ASCII)保存，只在被调用时进行解释或编译。

##### 代码链接

[1]: 

##### 锚点

[](#1)

##### 质疑

[^!1]: 

##### 疑问

[^?1]: 是否是特定类型的对象，转换为 object 不会出现问题？

