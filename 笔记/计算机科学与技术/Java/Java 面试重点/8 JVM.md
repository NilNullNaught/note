<div STYLE="page-break-after: always;">
	<br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
	<center><h3><font size="20px">
        JVM
    </font></h3></center>
	<br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
</div>


# 1	类加载过程

## 1.1	字节码

#### 什么是字节码

因为 JVM 针对各种操作系统和平台都进行了定制，无论在什么平台，都可以通过 javac 命令将一个 .java 文件编译成格式固定的字节码文件（.class 文件）供 JVM 使用。

之所以被称为字节码文件，是因为 .class 文件是由十六进制码组成的，十六进制的一位是 4 bit，JVM 以两个十六进制码为一组，也就是 8 bit = 1Byte，即一个字节为单位进行读取。

<br>

#### 字节码文件的组成结构

JVM 对字节码文件的规范是有要求的，要求每一个字节码文件都要有十个顺序固定的部分组成，如下图：

![](img/JVM/1.1/1.png)

###### 魔数

所有的 .class 文件的前 4 个字节都是魔数，魔数是一个固定值：0xCAFEBABE。魔数是 Java 之父 James Gosling 指定的，意为 CafeBabe（咖啡宝贝）。

JVM 可以根据文件的开头来判断这个文件是否是一个 .class 文件，如果文件以魔数开头，才会往后执行下面的操作。

###### 版本号

版本号是魔数之后的 4 个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version）。

比如 0000 0037，次版本号 0000 转为十进制是 0，主版本号 0037 转为十进制 55，对应下图的版本映射关系，可以看到对应的 Java 版本号是 JDK 11。

| jdk    | class file version |
| ------ | ------------------ |
| 1.0    | 45                 |
| 1.1    | 45                 |
| 1.2    | 46                 |
| 1.3    | 47                 |
| 1.4    | 48                 |
| 1.5    | 49                 |
| 1.6    | 50                 |
| 1.7    | 51                 |
| JDK 8  | 52                 |
| JDK 9  | 53                 |
| JDK 10 | 54                 |
| JDK 11 | 55                 |

###### 常量池

紧接着主版本号之后的字节为常量池入口，常量池中有两类常量：

1. **字面量**：字面量是代码中申明为 Final 的常量值；
2. **符号引用**：符号引用包括类和接口的全局限定名、字段的名称和标识符、方法的名称和标识符。

常量池整体分为两个部分：常量池计数器以及常量池数据区。

1. ![](img/JVM/1.1/2.png)

###### 访问标志

常量池结束后的两个字节，描述的是该 .class 文件是类还是接口，以及是否被 Public、Abstract、Final 等修饰符修饰，JVM 规范规定了 9 种访问标志（Access_Flag）。

访问标志的长度都是两个字节，而 .class 文件中给访问标志的长度也是两个字节。但是一个类可能会同时持有多个访问标志，为了能只用两个字节就完整的记录类的所有访问标志，JVM 使用 <u>按位或</u> 操作对多个访问标示进行运算。比如一个类的修饰符是 Public Final，则对应的访问修饰符的值为 ACC_PUBLIC | ACC_FINAL，即 0x0001 | 0x0010=0x0011。

| 标志名称      | 标志值 | 含义                       |
| ------------- | ------ | -------------------------- |
| ACC_PUBLIC    | 0x0001 | 字段是否为 public          |
| ACC_PRIVATE   | 0x0002 | 字段是否为 private         |
| ACC_PROTECTED | 0x0004 | 字段是否为 protected       |
| ACC_STATIC    | 0x0008 | 字段是否为 static          |
| ACC_FINAL     | 0x0010 | 字段是否为 final           |
| ACC_VOLATILE  | 0x0040 | 字段是否为 volatile        |
| ACC_TRANSTENT | 0x0080 | 字段是否为 transient       |
| ACC_SYNCHETIC | 0x1000 | 字段是否为由编译器自动产生 |
| ACC_ENUM      | 0x4000 | 字段是否为 enum            |

###### 当前类索引

访问标志后的两个字节，描述的是当前类的全限定名，这两个字节保存的值是常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。

###### 父类索引

当前类名后的两个字节，描述的父类的全限定名，也是保存的常量池中的索引值。

###### 接口索引

包括接口计数器和接口索引集合。

接口计数器是父类索引后的两个字节，描述了该类或者父类实现的接口数量。

接口索引集合紧接着的 n 个字节是 <u>类的所有接口的全限定名</u> 在常量池中的索引值。

###### 字段表

用于描述类和接口中声明的变量，包含类级别变量和实例级别变量，但是不包含方法内部声明的局部变量。

字段表也分为两个部分，第一部分通过两个字节描述字段个数，第二部分是每个字段的详细信息 fields_info。

![](img/JVM/1.1/3.png)

###### 方法表

字段表结束后是方法表，方法表也分为两个部分，第一部分通过两个字节描述方法的个数，第二部分是每个方法的详细信息。

方法的访问信息比较复杂，包括方法的访问标志、方法名、方法的描述符和方法的属性：

![](img/JVM/1.1/4.png)

###### 附加属性

字节码的最后一部分，存放了在该文件中类或接口所定义属性的基本信息。

<br>

#### 例——一个标准 Java 字节码文件

![](img/JVM/1.1/5.png)

<br>

----

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>
## 1.2	类加载过程

#### 类加载过程的五个主要步骤

类加载的机制过程分为5个部分：加载、验证、准备、解析、初始化

![](img/JVM/1.2/1.png)

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

## 1.3	类加载过程——类的初始化过程

#### 类的初始化过程简介

类的初始化阶段是真正开始执行类中定义的 Java 程序代码[^1.3-1]并按程序员的意图去初始化类变量的过程。

更直接地说，初始化阶段就是执行类构造器  `<clinit>()` 方法的过程。编译器自动手机 <u>类中的所有类变量的赋值动作</u> 和 <u>静态代码块</u>，将它们合并生成 `\<clinit>()` 方法。

<br>

#### Class 各部分的初始化顺序

**静态变量、静态初始化块（取决于它们在类中出现的先后顺序）**>**变量、初始化块（决于它们在类中出现的先后顺序）** > **构造器**

<br>

#### 类初始化的详细过程

在初始化一个类之前，先要获得与这个类相关联的锁对象（监视器），记作` LC`。

类或接口 `C` 的初始化流程如下（JVM 1.8 规范）：

1. 等待获取 `C` 的锁 ` LC`；

1. 获取到 ` LC` 后，根据 `C` 的状态进行以下操作：

   1. 如果 `C` 正在被其他线程初始化，释放 `LC`，并阻塞当前线程直到 `C` 初始化完成（线程中断对初始化过程没有影响）；
   1. 如果 `C` 正在被当前线程初始化，则肯定是在递归初始化时又触发 `C` 初始化，释放 `LC` 并正常返回；
   1. 如果 `C` 的状态为已经初始化，释放 `LC` 并正常返回；
   1. 如果 `C` 的状态为初始化失败，释放 `LC` 并抛出一个  `NoClassDefFoundError` 异常；
   1. 否则记录当前类 C 的状态为初始化中，并设置当前线程为初始化线程, 然后释放 `LC`。

1. 按照字节码文件中的顺序初始化 `C` 中每个带有 `ConstantValue` 属性的 `final` `static` 字段[^1.3-2]；

1. 如果 `C` 是一个类，而且它的父类还未初始化（父类记作 `SC`），并实现了至少包含一个非抽象、非静态方法的接口[^1.3-3]（记作 `SI1, ..., SIn`）。

    先初始化 `SC`，所有父接口的初始化顺序按照递归的顺序而不是继承层次的顺序确定。 对于一个被 `C` 直接实现的接口 `I` （按照 `C` 的接口列表 `interfaces` 的顺序）, 在 `I` 初始化之前，先循环遍历初始化 `I` 的父接口（按照 `I` 的接口列表 `interfaces` 的顺序）；

1. 查看定义类加载器是否开启了断言（用于调试）：

   ```java
   // ClassLoader
   
   // 查询类是否开启了断言
   /** 通过 setClassAssertionStatus(String, boolean)
   *		setPackageAssertionStatus(String, boolean)
   *		setDefaultAssertionStatus(boolean)
   *	设置断言
   */
   boolean desiredAssertionStatus(String className);
   ```

1. 执行 `C` 的初始化方法 `<clinit>`.

1. 如果 `C` 的初始化正常完成，获取 `LC` 并将 `C` 的状态标记为已完成初始化，唤醒所有等待线程，释放锁 `LC`，初始化过程完成.

1. 否则，初始化方法必须抛出一个异常 `E`。

   如果 `E` 不是 `Error` 或其子类，则需要创建一个 `ExceptionInInitializerError` 实例（以 `E` 作为参数），在接下来的步骤中，以这个实例替换 `E`。

   如果因为内存溢出无法创建 `ExceptionInInitializerError` 实例，用一个 `OutOfMemoryError` 替换 `E`；

1. 获取 `LC`，标记 C 的初始化状态为发生错误，通知所有等待线程，释放 `LC`，并通过 `E` 或其他替代（见前一步）异常返回。

<br>

---

[^1.3-1]: 此时这些 Java 代码已经被解析为字节码。
[^1.3-2]: 注意：JVM 规范把常量的赋值定义在初始化阶段，\<clinit>() 执行之前，具体实现未必严格遵守。如 hotspot 虚拟机在解析字节码过程创建 _java_mirror 镜像类时已为每个常量字段赋值。
[^1.3-3]: 这个接口可以是直接写在 C 上的，也可以通过继承获得的。

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>


## 1.4	Java 的类加载器

#### Bootstrap 类加载器

Bootstrap 类加载器又叫启动类加载器，使用 C++ 实现，没有父类，是虚拟机自身的一部分。

Bootstrap 类加载器主要加载的是 JVM 自身需要的类，它负责将 **<JAVA_HOME>/lib 路径下的核心类库** 或 **-Xbootclasspath 参数指定的路径下的 jar 包** 加载到内存中。

出于安全考虑，Bootstrap 启动类加载器只加载以 java、javax、sun 等开头的类。并且，由于虚拟机按照文件名识别并加载 jar 包，如果 jar 包的文件名不能被虚拟机识别，那么即使 jar 包在 lib 目录下也无法被加载。

<br>

#### Extention 类加载器

Extention 类加载器又叫扩展类加载器，由 `sun.misc.Launcher$ExtClassLoader` 实现，是 `java.lang.ClassLoader` 的子类。

Extention 类加载器负责加载 **<JAVA_HOME>/lib/ext目录下** 或 **由系统变量 -Djava.ext.dir 指定位路径中的类库**，开发者可以直接使用标准扩展类加载器。

<br>

#### Application 类加载器

Application 类加载器又叫应用程序加载器。父类加载器为 ExtClassLoader。

Application 类加载器负责加载 **系统类路径java -classpath** 或 **-D java.class.path 指定路径下的类库**，也就是我们经常用到的 **classpath 路径**，开发者可以直接使用系统类加载器，一般情况下 Application 类加载器是程序中默认的类加载器。

通过 `ClassLoader#getSystemClassLoader()` 方法可以获取到 Application 类加载器。
<br>

#### Custom 自定义类加载器

应用程序可以自定义类加载器，父类加载器为 AppClassLoader：

![](img/JVM/1.4/1.png)

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

## 1.5	双亲委派机制

#### 双亲委派机制是什么？

双亲委派模式指的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个 **请求委托给父类的加载器去执行**，如果父类加载器还存在其父类加载器，则 **进一步向上委托，依次递归**，**请求最终将到达顶层的启动类加载器**，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。

![](img/JVM/1.5/1.png)

<br>

#### 双亲委派的优点

   1. 每一个类都只会被加载一次，避免了重复加载；
   2. 每一个类都会被尽可能的加载（从引导类加载器往下，每个加载器都可能会根据优先次序尝试加载它）；
   3. 有效避免了某些恶意类的加载（比如用户自定义了一个 `Java.lang.Object` 类，一般而言在双亲委派模型下会加载系统的 `Object` 类而不是自定义的 `Object` 类）

<br>

#### 如何破坏双亲委派模型

###### 方式一——重写自定义加载器的 loadClass()

创建自定义类加载器时，一般只重写 `findClass()`，这样可以保持双亲委派机制。但是如果重写了 loadClass 方法，就可以定义加载规则。

###### 方式二——线程上下文类加载器（contextClassLoader）（❗ 关于 SPI 的部分十分混乱）

双亲委派模型很好地解决了各个类加载器的基础类统一问题（基础的类由上层的加载器进行加载），基础类之所以被称为 “基础”，是因为它们总是作为被调用代码调用的 API。但是，如果基础类又要调用用户的代码，那该怎么办呢？线程上下文类加载器就出现了。
1. SPI。这个类加载器可以通过 `java.lang.Thread` 类的 `setContextClassLoader()` 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。

   JNDI 服务使用线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。

1. 线程上下文类加载器默认情况下就是 `AppClassLoader`，那为什么不直接通过 `getSystemClassLoader()` 获取类加载器来加载 classpath 路径下的类的呢？其实是可行的，但这种方式有一个缺点，那就是代码部署到不同服务时会出现问题。例如，把代码部署到 Java Web 应用服务或者 EJB 之类的服务将会出问题，因为这些服务使用的线程上下文类加载器并非 `AppClassLoader`，而是 Java Web 应用服务自己的类加载器。所以我们应用该少用`getSystemClassLoader()`。

   总之不同的服务使用的可能默认 `ClassLoader` 是不同的，但使用线程上下文类加载器总能获取到与当前程序执行相同的`ClassLoader`，从而避免不必要的问题。

###### 方式三——用户对程序动态性的追求

“动态性”指的是：代码热替换、模块热部署等，简单的说就是机器不用重启，只要部署上就能用。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

# 2	JVM 内存模型

## 2.1	JVM 内存模型分配

![](img/JVM/2.1/1.png)

<br>

#### Java 运行时数据区

###### 程序计数器

程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是 **当前线程所执行的字节码的行号指示器**，用于记录当前虚拟机正在执行的线程指令地址。在 Java 虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

它是 **程序控制流的指示器**，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

###### Java 虚拟机栈

虚拟机栈描述的是 Java 方法执行的线程内存模型。每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

###### 本地方法栈

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 **本地（Native）方法** 服务。

###### Java 堆

对于 Java 应用程序来说，Java 堆（Java Heap）是虚拟机所管理的内存中 **最大** 的一块。Java 堆是 **被所有线程共享** 的一块内存区域，**在虚拟机启动时创建**。**此内存区域的唯一目的就是存放对象实例**，Java 世界里 **“几乎”** 所有的对象实例都在这里分配内存[^2.1-8]。

由于 Java 堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作 **GC堆（Garbage CollectedHeap）**。

###### 方法区

方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，**用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。虽然《Java 虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作 **非堆（Non-Heap**），目的是与 Java 堆区分开来。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

## 2.2	元空间

#### 什么是元空间

元空间是 JDK 8 以后，方法区新的实现方式（之前的是永久代）。

元空间不在 JVM 堆中，属于堆外内存，受最大物理内存限制。

可以通过 JVM 启动参数设置参数设置元空间大小（例如  -XX:MetaspaceSize=1024m -XX:MaxMetaspaceSize=1024m），具体的值根据情况设置。为避免动态申请，可以直接都设置为最大值。

<br>

#### JVM 8 为什么要增加元空间

1. 字符串存在永久代中，容易出现性能问题和内存溢出。
2. 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
3. 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

<br>

#### 元空间的特点

1. 每个加载器有专门的存储空间；
2. 不会单独回收某个类；
3. 元空间里的对象的位置是固定的；
4. 如果发现某个加载器不再使用，会其把相关的空间整个回收。

<br>

#### 线上元空间内存泄露问题与优化方案

###### 代理类导致的元空间内存泄漏问题

元空间主要存放的是类元数据，而且 metaspace 可以判断类元数据是否可以回收，判断依据是加载这些类元数据的Classloader是否可以回收，只要 Classloader 不能回收，通过其加载的类元数据就不会被回收。所以线上有时候会出现一种问题，由于框架中，往往大量采用类似 ASM、javassist 等工具进行字节码增强，生成代理类。如果项目中由主线程频繁生成动态代理类，那么就会导致元空间迅速占满，无法回收。

###### 优化方案

https://zhuanlan.zhihu.com/p/200802910

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

## 2.3	OOM 异常

#### 什么情况下会抛出 OOM 异常

OOM 异常并不是内存被耗空的时候才抛出。而是满足以下两个条件才会触发：

1. JVM 98% 的时间都在内存回收
2. 每次回收的内存小于2%

抛出 OOM 异常后，JVM 会留给系统一个微小的间隙以做一些 Down 之前的操作，比如手动打印 Heap Dump。

<br>

#### 系统OOM之前都有哪些现象？

- 每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5s
- FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC
- 老年代的内存越来越大并且每次FullGC后，老年代只有少量的内存被释放掉

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

# 3	垃圾回收

## 3.1	存活判定算法

#### 不同的引用类型的回收机制

1. 强引用：通过关键字new的对象就是强引用对象，强引用指向的对象任何时候都不会被回收，宁愿OOM也不会回收。
1. 软引用：如果一个对象持有软引用，那么当JVM堆空间不足时，会被回收。一个类的软引用可以通过java.lang.ref.SoftReference持有。
1. 弱引用：如果一个对象持有弱引用，那么在GC时，只要发现弱引用对象，就会被回收。一个类的弱引用可以通过java.lang.ref.WeakReference持有。
1. 虚引用：几乎和没有一样，随时可以被回收。通过PhantomReference持有。

<br>

#### 引用计数法（已被淘汰的算法）

每一个对象有一个引用属性，新增一个引用时加一，引用释放时减一，计数为0的时候可以回收。

但是这种计算方法，有一个致命的问题，无法解决循环引用的问题

<br>

#### 可达性分析算法

通过一系列称为 **“GC Roots”** 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，或者用图论的话来说就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。

###### Java 技术体系中，固定可作为 GC Roots 的对象

1. 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
2. 在方法区中类静态属性引用的对象，譬如 Java 类的引用类型静态变量。
3. 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
4. 在本地方法栈中 JNI（即通常所说的 Native 方法）引用的对象。
5. Java虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfM emoryError）等，还有系统类加载器。
6. 所有被同步锁（synchronized关键字）持有的对象。
7. 反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

## 3.2	垃圾回收算法

#### 标记-清除（Mark-Sweep）算法

分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

![](img/JVM/3.2/1.png)

###### 缺点

它的主要不足有两个：

1. 效率问题，标记和清除两个过程的效率都不高；
2. 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

<br>

#### 复制算法

为了解决效率问题，一种称为复制（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

![](img/JVM/3.2/2.png)

###### 缺点

**复制算法的代价** 是将内存缩小为了原来的一半，减少了实际可用的内存。

###### 复制算法的改进

IBM 公司的专门研究表明，新生代中的对象 98% 是“朝生夕死”的，所以并不需要按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的 90%（80%+10%），只有 10% 的内存会被浪费。

当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion)。

<br>

#### 分代收集算法

当前商业虚拟机的垃圾收集都采用分代收集（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清理或者标记—整理算法来进行回收。

<br>

#### 标记-整理算法

###### 复制算法不适合老年代

复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种算法。

###### 针对老年代提出的标记-整理算法

根据老年代的特点，有人提出了标记-整理（Mark-Compact）算法，标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

![](img/JVM/3.2/3.png)

<br>

----

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

##  3.3	JVM 有哪些垃圾回收器，实际中如何选择？

####  JVM 的七种主流垃圾回收器

![](img/JVM/3.3/1.png)

上图中展示了 7 种作用于不同分代的收集器，如果两个收集器之间存在连线，则说明它们可以搭配使用。虚拟机所处的区域则表示它是属于新生代还是老年代收集器。

###### 新生代收集器

1. Serial
2. ParNew
3. Parallel Scavenge

注意，这三种新生代收集器都是通过复制算法实现的。

###### 老年代收集器

1. CMS
2. Serial Old
3. Parallel Old（标记整理）

###### 整堆收集器

G1（一个 Region 中是标记-清除算法，2个 Region 之间是复制算法）

<br>

#### 垃圾收集器相关概念

1. **并行（Parallel）**：多个垃圾收集线程并行工作，此时用户线程处于等待状态
2. **并发（Concurrent）**：用户线程和垃圾收集线程同时执行
3. **吞吐量**：运行用户代码时间／（运行用户代码时间＋垃圾回收时间）

<br>

#### minorGC 和 Full GC

1. **新生代 GC（Minor GC/YGC）**：指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。
2. **老年代 GC（Major GC/Full GC）**：指发生在老年代的 GC，Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。

<br>

#### Stop The World 问题

指垃圾回收器在进行工作时，整个应用无法作出任何响应的问题。

<br>

#### Serial 收集器

Serial 收集器是最基本的、历史最悠久的收集器。

###### 实现算法

复制算法。

###### 特点

1. 单线程、简单高效（与其他收集器的单线程相比），对于单 CPU 环境，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。
2. 进行垃圾回收时，必须暂停其他所有的工作线程，直到回收结束。

###### 应用场景

适用于 Client 模式下的虚拟机。

###### Serial / Serial Old收集器运行示意图

![](img/JVM/3.3/2.png)

<br>

#### ParNew 收集器

ParNew 收集器其实是 Serial 收集器的多线程版本。除了使用多线程外其余行为均和 Serial 收集器一模一样（参数控制、收集算法、Stop The World、对象分配规则、回收策略等）。

###### 实现算法

复制算法。

###### 特点

1. 多线程、ParNew 收集器默认开启的收集线程数与 CPU 的数量相同，在多 CPU 环境中，可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数；
2. 和 Serial 收集器一样存在 Stop The World 问题。

###### 应用场景

ParNew 收集器是运行在 Server 模式下的虚拟机中首选的新生代收集器，因为它是除了 Serial 收集器外，唯一一个能与 CMS 收集器配合工作的。

###### ParNew/Serial Old组合收集器运行示意图

![](img/JVM/3.3/3.png)

<br>

#### Parallel Scavenge 收集器

Parallel Scavenge 收集器与吞吐量关系密切，故也称为吞吐量优先收集器。

###### 实现算法

复制算法。

###### 特点

1. 属于多线程收集器（与 ParNew 收集器类似）。
2. 该收集器的目标是达到一个可控制的吞吐量，Parallel Scavenge 收集器可以使用两个参数控制吞吐量：
   - **XX:MaxGCPauseMillis**：控制最大的垃圾收集停顿时间；
   - **XX:GCRatio**：直接设置吞吐量的大小。

###### GC 自适应调节策略

GC 自适应调节策略是 Parallel Scavenge 与 ParNew 收集器最重要的一个区别。

Parallel Scavenge 收集器可设置 -XX:+UseAdptiveSizePolicy 参数。使用该参数时不需要手动指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为 GC 的自适应调节策略。

<br>

#### Serial Old

Serial 收集器的老年代版本。

###### 实现算法

标记-整理算法。

###### 特点

1. 单线程；
2. STOP THE World 问题。

###### 应用场景

主要也是使用在Client模式下的虚拟机中。也可在Server模式下使用。

Server模式下主要的两大用途（在后续中详细讲解···）：

1. 在 JDK1.5 以及以前的版本中与Parallel Scavenge收集器搭配使用。
1. 作为 CMS 收集器的后备方案，在并发收集 Concurent Mode Failure 时使用。

###### Serial / Serial Old收集器工作过程图（Serial收集器图示相同）

![](img/JVM/3.3/4.png)

<br>

#### Parallel Old

Parallel Old 是 Parallel Scavenge 收集器的老年代版本。

###### 实现算法

标记-整理算法。

###### 特点

多线程。

###### 应用场景

注重高吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge + Parallel Old 收集器。

###### Parallel Scavenge/Parallel Old收集器工作过程图

![](img/JVM/3.3/5.png)

<br>

#### CMS 收集器

CMS 收集器是一种以获取最短回收停顿时间为目标的收集器。CMS 收集器的内存回收过程是与用户线程一起并发执行的。

###### 实现算法

标记-清除算法。

###### 特点

并发收集、低停顿。

###### 应用场景

适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如 web 程序、b/s 服务。

###### CMS 收集器的运行过程

1. **初始标记**：标记 GC Roots 能直接到的对象。速度很快但是仍存在 Stop The World 问题。
2. **并发标记**：进行 GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行。
3. **重新标记**：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在 Stop The World 问题。
4. **并发清除**：对标记的对象进行清除回收。

######  CMS 收集器的工作过程图

![](img/JVM/3.3/6.png)

###### CMS收集器的缺点

1. 对 CPU 资源非常敏感。
2. 无法处理浮动垃圾，可能出现 Concurrent Model Failure 失败而导致另一次 Full GC 的产生。因为采用标记-清除算法所以会存在空间碎片的问题，导致大对象无法分配空间，不得不提前触发一次 Full GC。

<br>

#### G1收集器

G1收集器一款面向服务端应用的垃圾收集器。

###### 特点

1. **并行与并发**：G1能充分利用多CPU、多核环境下的硬件优势，使用多个 CPU 来缩短 Stop-The-World 停顿时间。部分收集器原本需要停顿 Java 线程来执行 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续运行。
2. **分代收集**：G1 能够独自管理整个 Java 堆，并且采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。
3. **空间整合**：G1 运作期间不会产生空间碎片，收集后能提供规整的可用内存。
4. **可预测的停顿**：G1除了追求低停顿外，还能建立可预测的停顿时间模型。能在使用者明确指定的 M 毫秒内，消耗在垃圾收集上的时间不得超过 N 毫秒。

###### G1收集器运行示意图

![](img/JVM/3.3/7.png)
<br>

#### 如何选择垃圾收集器

###### 非必要不要修改垃圾收集器

除非应用程序有非常严格的暂停时间要求，否则使用 JVM 提供的默认 GC 即可。出现性能问题时，首先调整堆大小以提高性能。 

###### 选择垃圾收集器的一些准则

如果性能仍然不能满足目标，请使用以下准则作为选择收集器的起点：

   1. 如果应用程序的数据集较小（最大约 100 MB），则选择带有选项 `-XX：+ UseSerialGC` 的串行收集器。
   2. 如果应用程序将在单个处理器上运行，并且没有暂停时间要求，则选择带有选项 `-XX：+ UseSerialGC` 的串行收集器。
   3. 如果峰值应用程序性能是第一要务，并且没有暂停时间要求或可接受一秒或更长时间的暂停，则让 JVM 选择收集器或使用 `-XX：+ UseParallelGC` 选择并行收集器 。
   4. 如果响应时间比整体吞吐量更重要，并且垃圾收集暂停时间必须保持在大约一秒钟以内，则选择具有 `-XX：+ UseG1GC`。（值得注意的是 JDK9 中 CMS 已经被 Deprecated，不可使用！移除该选项）
   5. 如果使用的是 jdk8，并且堆内存达到了 16G，那么推荐使用 G1 收集器，来控制每次垃圾收集的时间。
   6. 如果响应时间是高优先级，或使用的堆非常大，请使用 `-XX：UseZGC` 选择完全并发的收集器。（值得注意的是 JDK11 开始可以启动 ZGC，但是此时 ZGC具有实验性质，在 JDK15 （2020/09 发布）中才取消实验性质的标签，可以直接显示启用，但是 JDK15 默认 GC 仍然是 G1）。

这些准则仅提供选择收集器的起点，因为性能取决于堆的大小，应用程序维护的实时数据量以及可用处理器的数量和速度。

如果推荐的收集器没有达到所需的性能，则首先尝试调整堆和新生代大小以达到所需的目标。 如果性能仍然不足，尝试使用其他收集器。

###### 总体原则

减少 STOP THE WORD 时间，使用并发收集器（比如 CMS+ParNew，G1）来减少暂停时间，加快响应时间，并使用并行收集器来增加多处理器硬件上的总体吞吐量。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>
## 3.4	如何进行 GC 日志分析？

#### GC 日志分析大致流程

为了方便分析 GC 日志信息，可以指定启动参数 `-Xloggc: app-gc.log`、`-XX:+PrintGCDetails`、`-XX:+PrintGCDateStamps`，便于详细地查看 GC 日志信息。

1. 使用 `jinfo pid` 查看当前 JVM 堆的相关参数；
1. 继续使用 `jstat -gcutil 2315 1s 10` 查看 10s 内当前堆的占用情况；
1. 也可以使用 `jmap -heap pid` 查看当前 JVM 堆的情况；
1. 我们可以继续使用 `jmap -F -histo pid | head -n 20`，查看前 20 行打印，即查看当前 top20 的大对象，一般从这里可以发现一些异常的大对象，如果没有，那么可以查看排名前 50 的大对象。
1. 最后使用 `jmap -F -dump:file=a.bin pid`（如果 dump 文件很大，可以压缩一下【tar -czvf a.tar.gz a.bin】）
1. 再之后，就是对 dump 文件进行分析了，使用 MAT 分析内存泄露

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

# 4	JVM 性能调优

## 4.1	JVM 性能调优的原则

#### JVM 性能调优的六个原则

1. **不要为了调优而调优**：多数的 Java 应用不需要在服务器上进行 GC 优化，虚拟机内部已有很多优化来保证应用的稳定运行，所以不要为了调优而调优，不当的调优可能适得其反；
1. **设置好 JVM 参数**：在应用上线之前，先考虑将机器的 JVM 参数设置到最优（适合）；
1. **调优前先优化项目架构和代码**：在进行 GC 优化之前，需要确认项目的架构和代码等已经没有优化空间。我们不能指望一个系统架构有缺陷或者代码层次优化没有穷尽的应用，通过 GC 优化令其性能达到一个质的飞跃；
1. **慎重进行 GC 优化**：GC 优化是一个系统而复杂的工作，没有万能的调优策略可以满足所有的性能指标。GC 优化必须建立在我们深入理解各种垃圾回收器的基础上，才能有事半功倍的效果；
1. **GC 内存最大化原则**：处理吞吐量和延迟问题时，垃圾处理器能使用的内存越大，即 java 堆空间越大垃圾收集效果越好，应用运行也越流畅。这称之为 GC 内存最大化原则；
1. **GC 调优 3 选 2**：在吞吐量、延迟、内存这三个属性中选择其中两个进行 jvm 调优，称之为 GC 调优 3 选 2。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

## 4.2	什么情况下需要 JVM 调优？

##### 需要 JVM 调优的常见情况


1. Heap 内存（老年代）持续上涨达到设置的最大内存值；
2. Full GC 次数频繁；
3. GC 停顿（Stop World）时间过长（超过1秒，具体值按应用场景而定）；
4. 应用出现 OutOfMemory 等内存异常；
5. 应用出现 OutOfDirectMemoryError 等内存异常；
6. 应用中有使用本地缓存且占用大量内存空间；
7. 系统吞吐量与响应性能不高或下降；
8. 应用的 CPU 占用过高不下或内存占用过高不下。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>
## 4.3	JVM 调优需要关注的指标

#### 吞吐量和低延迟

###### 吞吐量

用户代码时间 / （用户代码执行时间 + 垃圾回收时间）是评价垃圾收集器能力的重要指标之一，也是不考虑垃圾收集引起的停顿时间或内存消耗的前提下，垃圾收集器能支撑应用程序达到的最高性能指标。

吞吐量越高算法越好。

###### 低延迟

STW 越短，响应时间越好。评价垃圾收集器能力的重要指标，度量标准是缩短由于垃圾收集引起的停顿时间或完全消除因垃圾收集所引起的停顿，避免应用程序运行时发生抖动。

暂停时间越短算法越好。

###### 吞吐量与低延迟之间的取舍

在设计（或使用）GC 算法时，我们必须确定我们的目标。因为一个 GC 算法只可能针对两个目标之一（即只专注于最大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。

<br>

#### MinorGC 原则

**MinorGC 应该尽可能多的收集垃圾对象**，这被称为 MinorGC 原则。因为 FullGC 较耗时，是应用程序无法达到延迟要求或吞吐量的罪魁祸首。遵守这一原则可以降低应用程序 FullGC 的发生频率。

###### 吞吐量优先的垃圾回收器

使用 `-XX:+UseParallelGC`、` -XX:+UseParallelOldGC`，即常规的（PS/PO）。

###### 响应时间优先的垃圾回收器

CMS、G1

<br>

#### 堆的大小

###### 如何分析应该设置的堆的大小

在遵守业务系统对延迟和吞吐量的需求的前提下，对以下 4 点进行分析：

1. 统计 Minor GC 持续时间
1. 统计 Minor GC 的次数
1. 统计 Full GC 的最长持续时间
1. 统计最差情况下 Full GC 频率

统计 GC 持续时间和频率对优化堆的大小是主要着手点。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>
## 4.4	JVM 常用参数

#### 常用参数

1. **Xms**：设定程序启动时占用内存大小。一般来讲，大点，程序会启动的快一点，但是也可能会导致机器暂时变慢；
2. **Xmx**：设定程序运行期间最大可占用的内存大小。如果程序运行需要占用更多的内存，超出了这个设置值，就会抛出 OutOfMemory 异常；
3. **Xss**：设定每个线程的堆栈大小。这个就要依据你的程序，看一个线程大约需要占用多少内存，可能会有多少线程同时运行等；
4. **`-Xmn、-XX:NewSize`/`-XX:MaxNewSize、-XX:NewRatio`**：
   1. 高优先级：-XX:NewSize/-XX:MaxNewSize 
   1. 中优先级：-Xmn（默认等效 -Xmn=-XX:NewSize=-XX:MaxNewSize=?） 
   1. 低优先级：-XX:NewRatio 
5. 如果想在日志中追踪类加载与类卸载的情况，可以使用启动参数  `-XX:TraceClassLoading`、`-XX:TraceClassUnloading`。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>
## 4.5	JVM 常用性能调优工具

#### 常用工具

1. MAT
2. jvisualvm
3. jconsole
4. Arthas
5. show-busy-java-threads

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

# 5	线上问题排查与解决方案

## 5.1	线上排查问题的一般流程

#### CPU 占用过高排查流程

1. 利用 top 命令查出占 CPU 最高的进程 pid；
1. 查看该进程（假设 pid 为9876）下占用最高的线程 id，命令：`top -Hp 9876`；
1. 将其（假设线程 ID 为 6900）转换为 16 进制形式[^5.1-1]，命令：`printf '%x\n' 6900`；
1. 利用 jstack 打印出 java 线程调用栈信息，命令：`jstack 9876 | grep '0x1af4' -A 50 --color`。

<br>

#### 内存占用过高排查流程

1. 查找进程 id，命令：`top -d 2 -c`；
1. 查看 JVM 堆内存分配情况，命令：`jmap -heap pid`；
1. 查看占用内存比较多的对象，命令：`jmap -histo pid | head -n 100`；
1. 查看占用内存比较多的存活对象，命令：`jmap -histo:live pid | head -n 100`。

<br>

---

[^5.1-1]: 因为 java native 线程以 16 进制形式输出.

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>
## 5.2	如何进行堆Dump文件分析？

#### 自动导出 Dump 文件

可以通过指定启动参数 `-XX:+HeapDumpOnOutOfMemoryError`和 `-XX:HeapDumpPath=/usr/app/data/dump/heapdump.hpro`，在发生 OOM 的时候自动导出 Dump 文件。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>
## 5.3	内存溢出的原因有哪些，如何排查线上问题？

#### java.lang.OutOfMemoryError: ......java heap space..... 

堆栈溢出，代码问题的可能性极大

<br>

#### java.lang.OutOfMemoryError: GC over head limit exceeded 

系统处于高频的 GC 状态，而且回收的效果依然不佳的情况，就会开始报这个错误，这种情况一般是产生了很多不可以被释放的对象，有可能是引用使用不当导致，或申请大对象导致。

但是 java heap space 的内存溢出有可能不会报这个错误，也就是说可能是计算机内存不够导致的。

<br>

#### java.lang.OutOfMemoryError: PermGen space

jdk1.7 之前才会出现的问题 ，原因是系统的代码非常多或引用的第三方包非常多、或代码中使用了大量的常量、或通过 intern 注入常量、或者通过动态代码加载等方法，导致常量池的膨胀。

<br>

#### java.lang.OutOfMemoryError: Direct buffer memory

直接内存不足，因为 JVM 垃圾回收不会回收直接内存。

可能原因是直接或间接使用了 ByteBuffer 中的 allocateDirect 方法，但没有进行 clear。

<br>

#### java.lang.StackOverflowError 

Xss 设置的太小。

<br>

#### java.lang.OutOfMemoryError: unable to create new native thread

堆外内存不足，无法为线程分配内存区域

<br>

#### java.lang.OutOfMemoryError: request {} byte for {}out of swap

地址空间不够

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>
## 5.4	如何进行线上堆外内存泄漏的分析？

#### 问题简述

JVM 的堆外内存泄露的定位一直是个比较棘手的问题，使用 Netty 时尤其居多。

<br>

#### 分析方法

1. 对外内存的泄漏分析一般都是先从堆内内存分析的过程中衍生出来的。如果在分析堆内内存泄露过程中发现 **计算出来的 JVM 堆内存竟然大于了整个JVM的 Xmx 的大小**，那说明多出来的是堆外内存。

1. 如果使用了 Netty 堆外内存，那么可以自行监控堆外内存的使用情况，不需要借助第三方工具，我们是使用的“反射”拿到的堆外内存的情况

1. 逐渐缩小范围，直到 Bug 被找到。当我们确认某个线程的执行带来 Bug 时，可单步执行，可二分执行，定位到某行代码之后，跟到这段代码，然后继续单步执行或者二分的方式来定位最终出 Bug 的代码。这个方法屡试不爽，最后总能找到想要的 Bug

1. 熟练掌握 idea 的调试。这里，最常见的调试方式是 **预执行表达式**，以及通过 **线程调用栈**，死盯某个对象，就能够掌握这个对象的定义、赋值之类。

1. 在使用直接内存的项目中，最好建议配置 `-XX:MaxDirectMemorySize`，设定一个系统实际可达的最大的直接内存的值，默认的最大直接内存大小等于 `-Xmx` 的值

1. 排查堆外泄露，建议指定启动参数：

   1.  `-XX:NativeMemoryTracking=summary`
   1. `- Dio.netty.leakDetection.targetRecords=100`
   1. `-Dio.netty.leakDetection.level=PARANOID`

   后两个参数是 Netty 的相关内存泄露检测的级别与采样级别。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

## 5.5	线上频繁 FullGC 的优化方案

线上频繁 FullGC 的特征
1. 线上多个线程的 CPU 都超过了 100%，通过 jstack 命令可以看到这些线程主要是垃圾回收线程；
1. 通过 jstat 命令监控 GC 情况，可以看到 Full GC 次数非常多，并且次数在不断增加。

<br>

#### 排查流程

1. 使用 `top` 命令，找到 cpu占用最高的一个 **进程id**；
1. 使用`top -Hp 进程id`命令，找到 cpu占 用最高的 **线程id**；
1. 【printf "%x\n" **线程id 】**，假设16进制结果为 a；
1. jstack 线程id | grep '0xa' -A 50 --color；
1. 如果是正常的用户线程， 则通过该线程的堆栈信息查看其具体是在哪处用户代码处运行比较消 耗CPU；
1. 如果该线程是 VMThread，则通过 jstat-gcutil 命令监控当前系统的GC状况，然后通过 jmapdump:format=b,file=导出系统当前的内存数据。导出之后将内存情况放到eclipse的mat工具中进行分析即可得出内存中主要是什么对象比较消耗内存，进而可以处理相关代码；正常情况下会发现VM Thread指的就是垃圾回收的线程；
1. 再执行【jstat -gcutil  **进程id】, **看到结果，如果FGC的数量很高，且在不断增长，那么可以定位是由于内存溢出导致FullGC频繁，系统缓慢；
1. 然后就可以 Dump 出内存日志，然后使用MAT的工具分析哪些对象占用内存较大，然后找到对象的创建位置，处理即可。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>
## 5.6	线上 YGC 耗时过长优化方案有哪些？

#### 可能导致 YGC 耗时过长的原因

如果生命周期过长的对象越来越多（比如全局变量或者静态变量等），会导致标注和复制过程的耗时增加。

###### 导致对存活对象标注时间过长的原因

1. 可能是重载了 Object 类的 Finalize 方法，导致标注 Final Reference 耗时过长；
2. 或者 String.intern 方法使用不当，导致 YGC 扫描 StringTable 时间过长。可以通过以下参数显示GC处理 Reference 的耗时 `-XX:+PrintReferenceGC`。

###### 长周期对象积累过多的原因

1. 本地缓存使用不当，积累了太多存活对象；
1. 或者锁竞争严重导致线程阻塞，局部变量的生命周期变长。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

##  5.7	如何解决线上gc频繁的问题？

1. 查看监控，以了解出现问题的时间点以及当前FGC的频率（可对比正常情况看频率是否正常）
1. 了解该时间点之前有没有程序上线、基础组件升级等情况。
1. 了解JVM的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析 JVM 参数设置是否合理。
1. 再对步骤1中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用gc方法比较容易排查。
1. 针对大对象或者长生命周期对象导致的 FGC，可通过 `jmap -histo` 命令并结合dump堆内存文件作进一步分析，需要先定位到可疑对象。
1. 通过可疑对象定位到具体代码再次分析，这时候要结合 GC 原理和 JVM 参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

## 5.8	线上死锁是如何排查的？

1. 使用 jps 查找一个可能有问题的**进程id**
1. 然后执行 【jstack -F **进程id**】
1. 如果环境允许远程连接 JVM，可以使用 jconsole 或者 jvisualvm，图形化界面检测是否存在死锁。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

# 附录

##### 参考资料

- 主要参考资料——[2022年最新【Java经典面试题300问】面试必备，查漏补缺；多线程+spring+JVM调优+分布式+redis+算法](https://www.bilibili.com/video/BV15v4y1T7fz?p=80&spm_id_from=pageDriver&vd_source=87ed5edcdc8042ca0c34ee5bbeeda7b3) 发布于 2022/06/29；
- [1.3	类加载过程——类的初始化过程](#1.3	类加载过程——类的初始化过程)——[java类加载之初始化过程（附面试题）](https://juejin.cn/post/6844903987330695181) 发布于 2019/11/05；

<br>
