# 4	面向对象

## 4.1	面向对象相关的概念

##### 面向对象的程序设计

程序员必须要在 **解决方案空间**（机器模型，对实际问题进行建模的地方，如计算机）和 **问题空间**（实际解决的问题模型，即实际解决的问题模型）之间建立起一种关联。这个过程既费精力，又脱离编程语言本身的范畴。这使得程序代码很难编写，维护代价高昂。

面向对象的程序设计在此基础上跨出了一大步，程序员可利用一些工具表达“问题空间”内的元素。由于这种表达非常具有普遍性，所以不必受限于特定类型的问题。我们将问题空间中的元素以及它们在解决方案空间的表示称作 **对象（Object）**。

<br>

##### 对象的特征

一个对象具有自己的状态，行为和标识。这意味着对象有自己的内部数据（提供状态）、方法（产生行为），并彼此区分（每个对象在内存中都有唯一的地址）。

<br>

##### “纯粹”的面向对象程序设计方法

###### 万物皆对象

你可以将对象想象成一种特殊的变量。它存储数据，但可以在你对其“发出请求”时执行本身的操作。理论上讲，你总是可以从要解决的问题身上抽象出概念性的组件，然后在程序中将其表示为一个对象。

###### 程序是一组对象，通过消息传递来告知彼此该做什么

要请求调用一个对象的方法，你需要向该对象发送消息。

###### 每个对象都有自己的存储空间，可容纳其他对象

或者说，通过封装现有对象，可制作出新型对象。所以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。

###### 每个对象都有一种类型

根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class）是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。

###### 同一类所有对象都能接收相同的消息

例如，由于类型为“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收发送给"形状”的消息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括“圆”。这一特性称为对象的 “可替换性”，是 OOP 最重要的概念之一。

<br>

##### “万物皆对象”的矛盾

固执地要求所有东西都是一个对象（特别是一直到最底层级别）是一种设计错误；但是，完全逃避“对象”的概念似乎同样太过苛刻。

<br>

##### 类和对象之间的关系

所有对象都是唯一的，但同时也是具有相同的特性和行为的对象所归属的类的一部分。

<br>

##### 类和接口

每个对象仅能接受特定的请求。我们向对象发出的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。**“类型”与“接口”的对应关系是面向对象程序设计的基础**。

<br>

##### 对象的设计原则

在良好的面向对象设计中，**每个对象功能单一且高效**。这样的程序设计可以提高我们代码的复用性，同时也方便别人阅读和理解我们的代码。只有让人知道你提供什么服务，别人才能更好地将其应用到其他模块或程序中。

<br>

##### 面向对象和面向过程的区别

###### 面向过程

- 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
- 缺点：没有面向对象易维护、易复用、易扩展。

###### 面向对象

- 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。
- 缺点：性能比面向过程低。

<br>

##### 面向对象三大特性

- **封装**：封装是对象和类概念的主要特性。封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
- **继承**：继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。
- **多态性**：指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。

<br>

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

## 4.3	Java 面向对象基础

### 4.3.1	类的声明

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

### 4.3.2	创建对象

##### Java 创建对象的四种方式

- new 创建新对象
- 通过反射机制
- 采用 clone 机制
- 通过序列化机制

前两者都需要显式地调用构造方法。对于clone机制,需要注意浅拷贝和深拷贝的区别，对于序列化机制需要明确其实现原理，在 java 中序列化可以通过实现 `Externalizable` 或者 `Serializable` 接口来实现。

<br>

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

### 4.3.3	this 关键字

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>
### 4.4.4	equals() 与 hashCode()

##### == 和 equals 区别是什么

`==` 常用于相同的基本数据类型之间的比较，也可用于相同类型的对象之间的比较；

- 如果 `==` 比较的是基本数据类型，那么比较的是两个基本数据类型的值是否相等；
- 如果 `==` 是比较的两个对象，那么比较的是两个对象的引用，也就是判断两个对象是否指向了同一块内存区域；

equals 方法主要用于两个对象之间，检测一个对象是否等于另一个对象

看一看 Object 类中 equals 方法的源码：

```text
public boolean equals(Object obj) {
        return (this == obj);
    }
```

它的作用也是**判断两个对象是否相等**，一般有两种使用情况：

- 情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。
- 情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。

java语言规范要求 equals 方法具有以下特性

- 自反性：对于任意不为 null 的引用值 x，x.equals(x) 一定是 true。
- 对称性：对于任意不为 null 的引用值 x 和 y，当且仅当 x.equals(y) 是 true 时，y.equals(x) 也是 true。
- 传递性：对于任意不为 null 的引用值 x、y 和 z，如果 x.equals(y) 是true，同时 y.equals(z) 是true，那么 x.equals(z)一 定是true。
- 一致性：对于任意不为 nul l的引用值 x 和 y，如果用于 equals 比较的对象信息没有被修改的话，多次调用时 x.equals(y) 要么一致地返回 true 要么一致地返回 false。
- 对于任意不为null的引用值x，x.equals(null)返回false。

<br>

##### hashCode() 简介

`hashCode()` 的作用是获取哈希码，也称为散列码；它实际上返回的是一个 `int` 型整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()` 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。

散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）

<br>

##### 为什么要有 hashCode

当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 `hashcode` 值来判断对象加入的位置，同时也会与其他已经加入的对象的 `hashcode` 值作比较，如果没有相符的 `hashcode`，`HashSet` 会假设对象没有重复出现。

但是如果发现有相同 `hashcode` 值的对象，这时会调用 `equals()` 方法来检查 `hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 `equals()` 的次数，相应就大大提高了执行速度。

<br>

##### hashCode() 与 equals() 之间的关系

Java 对于 `eqauls()` 方法和 `hashCode()` 方法是这样规定的：

- 同一对象上多次调用 hashCode() 方法，总是返回相同的整型值。
- 如果 a.equals(b)，则一定有 a.hashCode() 一定等于 b.hashCode()。
- 如果 !a.equals(b)，则 a.hashCode() 不一定等于 b.hashCode()。此时如果 a.hashCode() 总是不等于 b.hashCode()，会提高 hashtables 的性能。
- a.hashCode()==b.hashCode() 则 a.equals(b) 可真可假
- a.hashCode()！= b.hashCode() 则 a.equals(b) 为假。

上面结论简记：

- 如果两个对象 equals，Java 运行时环境会认为他们的 hashCode 一定相等。
- 如果两个对象不 equals，他们的 hashCode 有可能相等。
- 如果两个对象 hashCode 相等，他们不一定 equals。
- 如果两个对象 hashCode 不相等，他们一定不 equals

补充：关于 equals() 和 hashCode() 的重要规范

- 规范1：若重写 equals() 方法，有必要重写 hashcode()方法，确保通过 equals()方法判断结果为 true 的两个对象具备相等的 hashcode() 方法返回值。说得简单点就是：“如果两个对象相同，那么他们的 hashCode 应该相等”。不过请注意：这个只是规范，如果非要写一个类让 equals() 方法返回 true 而 hashCode() 方法返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了 Java 规范，程序也就埋下了 BUG。
- 规范2：如果 equals() 方法返回 false，即两个对象“不相同”，并不要求对这两个对象调用 hashCode() 方法得到两个不相同的数。说的简单点就是：“如果两个对象不相同，他们的 hashCode 可能相同”。

<br>

##### 为什么重写 equals 方法必须重写 hashcode 方法

判断的时候先根据 hashcode 进行的判断，相同的情况下再根据 equals() 方法进行判断。如果只重写了 equals 方法，而不重写 hashcode 的方法，会造成 hashcode 的值不同，而 equals() 方法判断出来的结果为 true。

在Java中的一些容器中，不允许有两个完全相同的对象，插入的时候，如果判断相同则会进行覆盖。这时候如果只重写了 `equals()` 的方法，而不重写 hashcode 的方法，Object 中 hashcode 是根据对象的存储地址转换而形成的一个哈希值。这时候就有可能因为没有重写 hashcode 方法，造成相同的对象散列到不同的位置而造成对象的不能覆盖的问题。

<br>

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

## 4.4	对象回收

### 4.4.1	垃圾回收机制

##### 对象创建与生命周期

我们在使用对象时要注意的一个关键问题就是对象的创建和销毁方式。每个对象的生存都需要资源，尤其是内存。为了资源的重复利用，当对象不再被使用时，我们应该及时释放资源，清理内存。

<br>

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

### 4.4.2	finalize()

finalize 是在 `java.lang.Object` 里定义的方法，也就是说每一个对象都有这么个方法，这个方法在 `gc` 启动，该对象被回收的时候被调用。

一个对象的 finalize 方法只会被调用一次，finalize 被调用不一定会立即回收该对象，所以有可能调用 finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize 了，进而产生问题，因此不推荐使用 finalize 方法。

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

### 4.4.3	终结条件

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

## 4.5	封装

### 4.5.1	封装概述

##### 研发编程与应用编程

我们可以把编程的侧重领域划分为 **研发** 和 **应用**。

应用程序员调用研发程序员构建的基础工具类进行快速开发。研发程序员开发一个工具类，该工具类仅向应用程序员公开必要的内容，并隐藏内部实现的细节。这样可以有效地避免该工具类被错误的使用和更改，从而减少程序出错的可能。彼此职责划分清晰，相互协作。

<br>

##### 使用封装的原因

**如果工具类的创建者将类的内部所有信息都公开给调用者，那么有些使用规则就不容易被遵守**。因为前者无法保证后者是否会按照正确的规则来使用，甚至是改变该工具类。只有设定访问控制，才能从根本上阻止这种情况的发生。

<br>

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

### 4.5.2	访问权限

##### 为什么需要访问控制

1. 让应用程序员不要触摸他们不应该触摸的部分[^4.5.2-1]。
2. 使类库的创建者在不影响后者使用的情况下完善更新工具库。例如，我们开发了一个功能简单的工具类，后来发现可以通过优化代码来提高执行速度。假如工具类的接口和实现部分明确分开并受到保护，那我们就可以轻松地完成改造。

<br>

##### 访问权限控制符

Java 有三个显式关键字来设置类中的访问权限：`public`（公开），`private`（私有）和`protected`（受保护），除此之外还有默认权限 `default`。

| 修饰符    | 当前类 | 同一包内 | 相同包下的子类 | 不同包下的子类 | 其他包 |
| --------- | ------ | -------- | -------------- | -------------- | ------ |
| public    | Y      | Y        | Y              | Y              | Y      |
| protected | Y      | Y        | Y              | Y              | N      |
| default   | Y      | Y        | Y              | N              | N      |
| private   | Y      | N        | N              | N              | N      |

- **public** : 对所有类可见。
- **protected** : 对同一包内的类和所有子类可见。
- **default** (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。
- **private** : 在同一类内可见。

###### 📌private 和 protected 不能用于修饰外部类

但是可以修饰内部类。

<br>

---

[^4.5.2-1]: 请注意，这也是一个哲学决策。也有部分编程语言认为如果程序员有需要，应该让他们访问细节部分。

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

## 4.6	继承

### 4.6.1	继承概述

##### 面向对象编程的复用性

- 代码和设计方案的复用性是面向对象程序设计的优点之一。我们可以通过重复使用某个类的对象来达到这种复用性。同时，我们也可以将一个类的对象作为另一个类的成员变量使用。新的类可以是由任意数量和任意类型的其他对象构成。

<br>

##### 通过继承复用代码

- 在创建了一个类之后，我们可以对其进行“克隆”，使另一个新类与其具有相似的功能，再根据情况进行添加和修改。“继承”正是针对这个目标而设计的。

  但继承并不完全等价于克隆。在继承过程中，若原始类（正式名称叫作基类、超类或父类）发生了变化，修改过的“克隆”类（正式名称叫作继承类或者子类）也会反映出这种变化。

<br>

##### 组合与聚合

###### 说明

组合和聚合都属于关联关系的一种，只是额外具有 **整体-部分** 的意义。

###### 组合

组合（Composition）经常用来表示“拥有”关系（has-a relationship）。例如，“汽车拥有引擎”。

###### 聚合

聚合（Aggregation），**动态的组合**。

###### 区分组合与聚合

需要根据实际的业务需求来判断是聚合还是组合。可能相同超类和子类，在不同的业务场景，关联关系会发生变化。**只看代码是无法区分聚合和组合的**，具体是哪一种关系，只能从语义级别来区分。聚合关系中，整件不会拥有部件的生命周期，所以整件删除时，部件不会被删除。再者，多个整件可以共享同一个部件。组合关系中，整件拥有部件的生命周期，所以整件删除时，部件一定会跟着删除。而且，多个整件不可以同时共享同一个部件。这个区别可以用来区分某个关联关系到底是组合还是聚合。**两个类生命周期不同步，则是聚合关系，生命周期同步就是组合关系。**

<br>

##### 创建新类时，优先考虑通过组合而不是继承复用代码

- 在面向对象编程中经常重点强调“继承”。在新手程序员的印象里，或许先入为主地认为“继承应当随处可见”。沿着这种思路产生的程序设计通常拙劣又复杂。相反，在创建新类时首先要考虑“组合”，因为它更简单灵活，而且设计更加清晰。

<br>

##### is-a 与 is-like-a

###### is-a

如果继承只覆盖基类的方法，基类和派生类就是相同的类型了，因为它们具有相同的接口。这会造成，你可以用一个派生类对象完全替代基类对象，这叫作"纯粹替代"，也经常被称作"替代原则"。

在某种意义上，这是一种处理继承的理想方式。我们经常把这种基类和派生类的关系称为是一个（is-a）关系，因为可以说"圆是一个形状"。

###### is-like-a

有时你在派生类添加了新的接口元素，从而扩展接口。虽然新类型仍然可以替代基类，但是这种替代不完美，原因在于基类无法访问新添加的方法。这种关系称为像是一个(is-like-a)关系。新类型不但拥有旧类型的接口，而且包含其他方法，所以不能说新旧类型完全相同。

<br>

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

### 4.6.2	Java 的单继承语法

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>
### 4.6.3	Object 类

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

### 4.6.4	super

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

### 4.6.5	方法覆盖

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

### 4.6.4	final 关键字

##### final 变量

被修饰的变量不可变，不可变分为 **引用不可变** 和 **对象不可变**[^4.6.4-1]，final 指的是引用不可变，final 修饰的变量必须初始化，通常称被修饰的变量为 `常量`。

<br>

##### final 方法

被修饰的方法不允许任何子类重写，子类可以使用该方法。

<br>

##### final 类

被修饰的类不能被继承，所有方法不能被重写。

<br>

---

[^4.6.4-1]: 指对象本身的状态不可变。

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

## 4.7	多态

### 4.7.1	Java 多态

##### Java 实现多态的原理

本质上多态分两种：

- 编译时多态（又称静态多态）
- 运行时多态（又称动态多态）

重载（overload）就是编译时多态的一个例子，编译时多态在编译时就已经确定，运行的时候调用的是确定的方法。

**我们通常所说的多态指的都是运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定。**这也是为什么有时候多态方法又被称为延迟方法的原因。

Java实现多态有 3 个必要条件：继承、重写和向上转型。只有满足这 3 个条件，开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而执行不同的行为。

- 继承：在多态中必须存在有继承关系的子类和父类。
- 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
- 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。

<br>

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

### 4.7.2	重载（Overload）和重写（Override）

方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。

- 重写发生在子类与父类之间, 重写方法返回值和形参都不能改变，与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分。**即外壳不变，核心重写！**
- 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。

![img](https://pic1.zhimg.com/80/v2-80e1e23ed5074ca7156355f244455914_720w.jpg)

<br>

##### 重载的方法不能根据返回值类型进行区分

不能根据返回值类型来区分重载的方法。因为调用时不指定类型信息，编译器不知道你要调用哪个函数。

```text
float max(int a, int b);
int max(int a, int b);
```

当调用`max（1,2）;`时无法确定调用的是哪个，单从这一点上来说，仅返回值类型不同的重载是不应该允许的。

<br>

##### 构造器不可以被重写

构造器不能被继承，因此不能被重写，但可以被重载。

<br>

##### 构造器的重载

每一个类必须有自己的构造函数，负责构造自己这部分的构造。子类不会覆盖父类的构造函数，相反必须一开始调用父类的构造函数。

<br>

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

### 4.7.2	抽象类与接口

##### 抽象类和接口的区别

###### 语法层面上的区别

1. 抽象类可以提供成员方法的实现细节，而接口中只能存在 `public abstract` 方法；
2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 `public static final` 类型的；
3. 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

###### 设计层面上的区别

1. 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。
2. 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。

<br>

#####  抽象类不能使用 final 修饰

定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类。

<br>

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

### 4.7.3	向上转型

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

## 4.8	static

##### static 的作用

`static` 关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。

<br>

##### 为什么需要 static

通常来说，用 `new` 创建类的对象时，数据存储空间才被分配，方法才供外界调用。但有时我们只想为特定域分配单一存储空间，不考虑要创建多少对象或者说根本就不创建任何对象，再就是我们想在没有创建对象的情况下也想调用方法。在这两种情况下，`static` 关键字，满足了我们的需求。

<br>

##### static 方法不能被覆盖的原因

Java 中 `static` 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 `static` 方法是编译时静态绑定的。`static` 方法跟类的任何实例都不相关，所以概念上不适用。

<br>

##### 是否可以在 static 环境中访问非 static 变量？

`static` 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 `static` 变量进行初始化。如果你的代码尝试不用实例来访问非 `static` 的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。

<br>

##### static 静态方法能不能引用非静态资源？

不能，new的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它。

<br>

##### static静态方法里面能不能引用静态资源？

可以，因为都是类初始化的时候加载的，大家相互都认识。

<br>

##### 非静态方法里面能不能引用静态资源？

可以，非静态方法就是实例方法，那是new之后才产生的，那么属于类的内容它都认识。

<br>

#####  java 静码块的执行顺序

基本上代码块分为三种：

- Static 静态代码块
- 构造代码块
- 普通代码块

而这三种代码块的执行顺序是：**静态代码块 → 构造代码块 → 构造函数 → 普通代码块**

继承中代码块执行顺序：**父类静态块 → 子类静态块 → 父类代码块 → 父类构造器 → 子类代码块 → 子类构造器**

<br>

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

## 4.9	内部类

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

## 4.10	可变参数列表与其实现原理

---

<div STYLE="page-break-after: always;">
    <br>
    <br>
    <br>
    <br>
    <br>
</div>

# 附录

##### 最后编辑时间

- 0000/00/00

##### 环境

- 

##### 参考资料

- 

##### 相关资料

- 

##### 代码链接

[1]:

##### 锚点

[](#1) 

##### 脚注

