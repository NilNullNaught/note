<div STYLE="page-break-after: always;">
	<br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
	<center><h3><font size="20px">
        Redis
    </font></h3></center>
	<br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
</div>


# 1	Redis 概述

## 1.1	Redis 的数据类型

##### Redis 的数据类型

Redis 有八种数据类型，其中包括常用的五大数据类型：

1. String（字符串）：Redis 中的 String 类型是 **二进制安全** 的，这意味着 String 类型的 value 可以包含任何类型的数据，比如 jpg 图片或者序列化的对象。
2. Hash（哈希）：Redis 中的 hash 是一个键值对集合，本质上是 String 类型 field 和 value 的映射表。适合存储对象。
3. List（列表）：Redis 列表是简单的字符串列表，按照插入顺序排序。可以添加元素到列表的头部（左边）或者尾部（右边）。
4. Set（集合）：Redis 的 Set 是 string 类型的无序集合，不允许重复。Set 通过哈希表实现，所以添加、删除、查找的复杂度都是 O(1)。

5. zset（有序集合）：和 set 一样也是 string 类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。zset 的成员是唯一的，但不同成员的分数（score）可以重复。

三种特殊数据类型：

1. geospatial（地理位置）
2. hyperloglog
3. bitmaps

<br>

----

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

## 1.2	Redis 在项目中应用场景

##### 主要应用场景

1. 缓存
2. 分布式锁

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

## 1.3	Redis 过期键的删除策略

##### 过期精度

在 Redis 2.4 及以前版本，过期期时间可能不是十分准确，有0-1秒的误差。

从 Redis 2.6 起，过期时间误差缩小到0-1毫秒。

<br>

##### 过期和持久

Keys 的过期时间使用 Unix 时间戳存储（从 Redis 2.6开始以毫秒为单位）。这意味着即使 Redis 实例不可用，时间也是一直在流逝的。

要想过期的工作处理好，计算机必须采用稳定的时间。 如果你将RDB文件在两台时钟不同步的电脑间同步，有趣的事会发生（比如所有的 keys装载时就会过期）。

即使正在运行的实例也会检查计算机的时钟，例如如果你设置了一个 key 的有效期是 1000 秒，然后设置你的计算机时间为未来 2000 ，这时 key 会立即失效，而不是等 1000 秒之后。

<br>

##### Redis 如何淘汰过期的 keys

Redis keys过期有两种方式：被动和主动方式。

###### 主动方式

当一些客户端尝试访问 key 时，过期的 key 会被发现并主动的过期。当然，这样是不够的，因为有些过期的 keys，可能永远不会访问他们，这部分 key 会通过被动方式淘汰。

###### 被动方式

Redis 会定时测试随机 keys 的过期时间。所有这些 keys 已经过期将会从密钥空间删除。

具体就是 Redis 每秒 10 次做的事情：

1. 对随机的 20 个 keys 进行相关过期检测
2. 删除所有已经过期的 keys。
3. 如果有多于 25% 的 keys 过期，重复第一步

这是一个平凡的概率算法，基本上的假设是，我们的样本是这个密钥控件，并且我们不断重复过期检测，直到过期的 key s的百分百低于 25%，这意味着，在任何给定的时刻，最多会清除 1/4 的过期 keys。

<br>

##### 在复制AOF文件时如何处理过期（❗表述不清）

为了获得正确的行为而不牺牲一致性，当一个 key 过期，DEL 命令将会随着 AOF 文件一起合成到所有附加的 slaves。在 master 实例中，这种方法是集中的，并且不存在一致性错误的机会。

然而，当 slaves 连接到 master 时，不会独立过期 keys（会等到 master 执行 DEL 命令），他们仍然会在数据集里面存在，所以当 slave 当选为 master 时，淘汰 keys 会独立执行，然后成为 master。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

## 1.4	Redis 持久化机制

##### Redis 提供的两种持久化方式

Redis 提供了 RDB 和 AOF 两种持久化方式。如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。

<br>

##### RDB

半持久化模式，也称为快照模式。RDB 持久化方式能够在指定的时间间隔能对 Redis 数据进行快照存储。

###### RDB的优点

1. **文件小**：RDB 是一个非常紧凑的文件，它保存了某个时间点的数据集，非常适用于数据集的备份，比如你可以每个小时保存一次数据，同时保存过去 30 天的数据,这样即使出了问题你也可以根据需求恢复到不同版本的数据集；

2. **是单一文件**：RDB 是一个紧凑的单一文件，可以很方便传送到另一个远端数据中心，非常适用于灾难恢复；

3. **性能更高**：RDB 在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以 RDB 持久化方式可以最大化 redis 的性能；

4. **适合回复大型数据**：与 AOF 相比，在恢复大的数据集的时候，RDB 方式会更快一些.

###### RDB的缺点

1. **数据丢失**：如果你希望在 redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么 RDB不 适合你。虽然你可以配置不同的 save 时间点（例如每隔5分钟并且对数据集有100个写的操作），但是 Redis 要完整的保存整个数据集是一个比较繁重的工作，间隔太短会严重影响服务器性能。通常会每隔5分钟或者更久做一次完整的保存。如果 Redis 意外宕机，你可能会丢失几分钟的数据；

2. **保存大量数据时会导致性能问题**：有RDB 需要经常 fork 子进程来保存数据集到硬盘上，当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。如果数据集巨大并且 CPU 性能不是很好的情况下，这种情况会持续不短的时间。AOF 也需要 fork，但是你可以调节重写日志文件的频率来提高数据集的耐久度.

<br>

##### AOF

全持久化模式，以日志形式记录对数据库的写操作，**它默认设置每秒对数据库的写操作做命令记录（命令记录通过 redis 协议追加保存每次写操作到文件末尾）**，当服务器重启的时候会重新执行这些命令来恢复原始的数据。

Redis 还能对 AOF 文件进行后台重写,使得AOF文件的体积不至于过大.

###### **AOF 优点**

1. **使用 AOF 会让你的Redis更加耐久**：你可以使用不同的 fsync 策略：

   1. 无 fsync
   2. 每秒 fsync
   3. 每次写的时候 fsync

   使用默认的每秒 fsync 策略，Redis 的性能依然很好（fsync 是由后台线程进行处理的，主线程会尽力处理客户端请求)，一旦出现故障，最多丢失 1 秒的数据。

2. **健壮性高**：AOF文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因（磁盘空间已满，写的过程中宕机等等）未执行完整的写入命令，你也也可使用 redis-check-aof 工具修复这些问题；

3. **Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写**： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。

4. **AOF 易于分析和导出**：AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。

###### AOF 缺点

1. **文件体积大**：对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。
2. **对数据库性能造成持续影响**：根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。

<br>

##### 同时开启两种持久化方式

你也可以同时开启两种持久化方式，在这种情况下, 当 redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。

<br>

##### 4.X 版本的整合策略

4.X 版本在 AOF 重写策略上做了优化。

在重写 AOF 文件时，4.x版本以前是把内存数据集的操作指令落地，而新版本是把内存的数据集以 rdb 的形式落地。这样重写后的AOF依然追加的是日志，但是，在恢复的时候是先 rdb 再增量的日志，性能更优秀。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

# 2	Redis 线程

## 2.1	Redis 是单线程还是多线程？

##### Redis 只有一个工作线程

Redis 所有版本中，都只有一个工作线程。但是，在 6.x 以上的版本出现了 IO 多线程。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

## 2.2	redis线程模型有哪些，单线程为什么快？（❗本章内容相当混乱，完全不清楚是在说什么）



##### IO 模型维度的特征

IO模型使用了多路复用器，在 linux 系统中使用的是 EPOLL；

类似 netty 的 BOSS，WORKER 使用一个 EventLoopGroup(threads=1)

单线程的 Reactor 模型，每次循环取 socket 中的命令然后逐一操作，可以保证socket中的指令是按顺序的，不保证不同的 socket 也就是客户端的命令的顺序性。

命令操作在单线程中顺序操作，没有多线程的困扰不需要锁的复杂度，在操作数据上相对来说是原子性质的。

<br>

##### 架构设计模型

自身的内存存储数据，读写操作不设计磁盘 IO

redis 除了提供了 Value 具备类型还为每种类型实现了一些操作命令

实现了计算向数据移动，而非数据想计算移动，这样在IO的成本上有一定的优势

且在数据结构类型上，丰富了一些统计类属性，读写操作中，写操作会 O(1) 负载度更新 length 类属性，使得读操作也是 O(1) 的

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

## 2.3	Redis 存在线程安全问题吗？

##### Redis 可以解决自身的线程安全问题，但无法避免外部导致的线程安全问题

Redis 可以保证内部串行，但是 Redis 外部的业务可能会导致线程问题。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

# 3	Redis 缓存

## 3.1	Redis 缓存如何回收

##### 回收进程的工作流程

1. 一个客户端运行了新的命令，添加了新的数据。
2. Redis 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。
3. 一个新的命令被执行，等等。
4. 所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。

如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。（因此不要在一条命令中存入太多数据）

<br>

##### 回收策略

1. noeviction：返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）
2. allkeys-lru：尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
3. volatile-lru：尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
4. allkeys-random：回收随机的键使得新添加的数据有空间存放。
5. volatile-random：回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
6. volatile-ttl：回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。
7. volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键
8. allkeys-lfu：从所有键中驱逐使用频率最少的键

<br>

##### 如何选择回收策略

如果没有键满足回收的前提条件的话，策略 **volatile-lru**, **volatile-random** 以及 **volatile-ttl** 就和 noeviction 差不多了。

选择正确的回收策略是非常重要的，这取决于你的应用的访问模式，不过你可以在运行时进行相关的策略调整，并且监控缓存命中率和没命中的次数，通过 RedisINFO 命令输出以便调优。

一般的经验规则:

- 使用 **allkeys-lru** 策略：当你希望你的请求符合一个幂定律分布，也就是说，你希望部分的子集元素将比其它其它元素被访问的更多。如果你不确定选择什么，这是个很好的选择。.
- 使用 **allkeys-random**：如果你是循环访问，所有的键被连续的扫描，或者你希望请求分布正常（所有元素被访问的概率都差不多）。
- 使用 **volatile-ttl**：如果你想要通过创建缓存对象时设置TTL值，来决定哪些对象应该被过期。

**allkeys-lru** 和 **volatile-random** 策略对于当你想要单一的实例实现缓存及持久化一些键时很有用。不过一般运行两个实例是解决这个问题的更好方法。

为了键设置过期时间也是需要消耗内存的，所以使用 **allkeys-lru** 这种策略更加高效，因为没有必要为键取设置过期时间当内存有压力时。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

## 3.2	缓存雪崩、缓存穿透、缓存击穿在实际中如何处理

##### 缓存穿透

缓存穿透是指 **查询一个一定不存在的数据**，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。

###### 解决方案

有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用 **布隆过滤器**，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

<br>

##### 缓存击穿

对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一 key 缓存，前者则是很多 key。

缓存在某个时间点过期的时候，恰好在这个时间点对这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。

###### 解决方案

1. 使用互斥锁（mutex key）：业界比较常用的做法。如果线程一查询缓存未命中，这时它会去获取互斥锁，然后查询数据库获取结果并将结果写入缓存中，最后释放锁。在线程一释放锁之前，其它线程都不能获取锁，只能睡眠一段时间后重试，如果能命中缓存，则返回数据，否则继续尝试获取互斥锁。
2. 逻辑过期：逻辑过期是指不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间。

<br>

##### 缓存雪崩

缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB，DB 瞬时压力过重雪崩。

###### 缓存雪崩和缓存击穿的区别

主要区别在于缓存击穿针对某一 key 缓存，缓存雪崩则是很多 key。

###### 解决方案

缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案：将缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

# 4	Redis 事务

## 4.1	redis 事务的实现方式（❗需要修改完善）

##### 事务相关命令

MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：

1. 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
2. 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

<br>

##### MULTI

开启事务。

<br>

##### EXEC

EXEC 命令负责触发并执行事务中的所有命令，如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。

另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。

<br>

##### 事务只进行一半导致的 AOF 持久化问题


当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。

然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。

如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。

使用redis-check-aof程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。

<br>

##### 事务中的错误

使用事务时可能会遇上以下两种错误：

1. 事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。
2. 命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。

对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。

不过，从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。

在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。

至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

## 4.2	为什么 Redis 不支持回滚

##### Redis 不支持回滚的理由

如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。

以下是这种做法的优点：

1. Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，**从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中**。
2. **因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速**。

有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是，**在通常情况下， 回滚并不能解决编程错误带来的问题**。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR， 回滚是没有办法处理这些情况的。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

# 5	Redis 集群

## 5.1	Redis 集群方案（❗需要修改完善）

##### 常见集群分类

1. 主从复制集群
2. 分片集群

<br>

##### redis 集群方案

1. 主从复制集群，手动切换

2. 带有哨兵的HA的主从复制集群

3. 客户端实现路由索引的分片集群

4. 使用中间件代理层的分片集群

5. redis自身实现的cluster分片集群


<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

## 5.2	redis主从复制的原理（❗需要修改完善）

##### Redis 主从复制机制

当一个 master 实例和一个 slave 实例连接正常时， master 会发送一连串的命令流来保持对 slave 的更新，以便于将自身数据集的改变复制给 slave （包括客户端的写入、key 的过期或被逐出等等）

当 master 和 slave 之间的连接断开之后，因为网络问题、或者是主从意识到连接超时， slave 重新连接上 master 并会尝试进行部分重同步：这意味着它会尝试只获取在断开连接期间内丢失的命令流。

当无法进行部分重同步时， slave 会请求进行全量重同步。这会涉及到一个更复杂的过程，例如 master 需要创建所有数据的快照，将之发送给 slave ，之后在数据集更改时持续发送命令流到 slave 。

<br>

##### 主从复制的关注点

Redis 使用异步复制，slave 和 master 之间异步地确认处理的数据量

一个 master 可以拥有多个 slave

slave 可以接受其他 slave 的连接。除了多个 slave 可以连接到同一个 master 之外， slave 之间也可以像层叠状的结构（cascading-like structure）连接到其他 slave 。自 Redis 4.0 起，所有的 sub-slave 将会从 master 收到完全一样的复制流。

Redis 复制在 master 侧是非阻塞的。这意味着 master 在一个或多个 slave 进行初次同步或者是部分重同步时，可以继续处理查询请求。

复制在 slave 侧大部分也是非阻塞的。当 slave 进行初次同步时，它可以使用旧数据集处理查询请求，假设你在 redis.conf 中配置了让 Redis 这样做的话。否则，你可以配置如果复制流断开， Redis slave 会返回一个 error 给客户端。但是，在初次同步之后，旧数据集必须被删除，同时加载新的数据集。 slave 在这个短暂的时间窗口内（如果数据集很大，会持续较长时间），会阻塞到来的连接请求。自 Redis 4.0 开始，可以配置 Redis 使删除旧数据集的操作在另一个不同的线程中进行，但是，加载新数据集的操作依然需要在主线程中进行并且会阻塞 slave 。

复制既可以被用在可伸缩性，以便只读查询可以有多个 slave 进行（例如 O(N) 复杂度的慢操作可以被下放到 slave ），或者仅用于数据安全。

可以使用复制来避免 master 将全部数据集写入磁盘造成的开销：一种典型的技术是配置你的 master Redis.conf 以避免对磁盘进行持久化，然后连接一个 slave ，其配置为不定期保存或是启用 AOF。但是，这个设置必须小心处理，因为重新启动的 master 程序将从一个空数据集开始：如果一个 slave 试图与它同步，那么这个 slave 也会被清空。

任何时候数据安全性都是很重要的，所以如果 master 使用复制功能的同时未配置持久化，那么自动重启进程这项应该被禁用。

<br>

##### Redis 复制功能是如何工作的

每一个 Redis master 都有一个 replication ID ：这是一个较大的伪随机字符串，标记了一个给定的数据集。每个 master 也持有一个偏移量，master 将自己产生的复制流发送给 slave 时，发送多少个字节的数据，自身的偏移量就会增加多少，目的是当有新的操作修改自己的数据集时，它可以以此更新 slave 的状态。复制偏移量即使在没有一个 slave 连接到 master 时，也会自增，所以基本上每一对给定的

> Replication ID, offset

都会标识一个 master 数据集的确切版本。

当 slave 连接到 master 时，它们使用 PSYNC 命令来发送它们记录的旧的 master replication ID 和它们至今为止处理的偏移量。通过这种方式， master 能够仅发送 slave 所需的增量部分。但是如果 master 的缓冲区中没有足够的命令积压缓冲记录，或者如果 slave 引用了不再知道的历史记录（replication ID），则会转而进行一个全量重同步：在这种情况下， slave 会得到一个完整的数据集副本，从头开始。

下面是一个全量同步的工作细节：

master 开启一个后台保存进程，以便于生产一个 RDB 文件。同时它开始缓冲所有从客户端接收到的新的写入命令。当后台保存完成时， master 将数据集文件传输给 slave， slave将之保存在磁盘上，然后加载文件到内存。再然后 master 会发送所有缓冲的命令发给 slave。这个过程以指令流的形式完成并且和 Redis 协议本身的格式相同。

你可以用 telnet 自己进行尝试。在服务器正在做一些工作的同时连接到 Redis 端口并发出 [SYNC](https://redis.io/commands/sync) 命令。你将会看到一个批量传输，并且之后每一个 master 接收到的命令都将在 telnet 回话中被重新发出。事实上 SYNC 是一个旧协议，在新的 Redis 实例中已经不再被使用，但是其仍然向后兼容：但它不允许部分重同步，所以现在 **PSYNC** 被用来替代 SYNC。

之前说过，当主从之间的连接因为一些原因崩溃之后， slave 能够自动重连。如果 master 收到了多个 slave 要求同步的请求，它会执行一个单独的后台保存，以便于为多个 slave 服务。

<br>

##### 无需磁盘参与的复制

正常情况下，一个全量重同步要求在磁盘上创建一个 RDB 文件，然后将它从磁盘加载进内存，然后 slave以此进行数据同步。

如果磁盘性能很低的话，这对 master 是一个压力很大的操作。Redis 2.8.18 是第一个支持无磁盘复制的版本。在此设置中，子进程直接发送 RDB 文件给 slave，无需使用磁盘作为中间储存介质。

<br>

---

<div STYLE="page-break-after: always;"><br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br></div>

# 附录

##### 参考资料

- 
- [1.1	Redis 的数据类型](#1.1	Redis 的数据类型)——[Redis 数据类型](https://www.runoob.com/redis/redis-data-types.html) 发布于 **无法确定发布时间**；

<br>