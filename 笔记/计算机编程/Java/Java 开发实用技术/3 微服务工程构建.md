# 微服务工程构建

## 1	基本项目构建

##### 一般微服务的工程结构

![img](img/592a017b-f501-4359-b92f-8b75875c45f7.png)

**guli-parent：根目录（父工程），管理四个子模块：**

- **canal-client：canal数据库表同步模块（统计同步数据）**

- **common**：公共模块父节点
  - **common-util**：工具类模块，所有模块都可以依赖于它。
  - **service-base**：service 服务的 base 包，包含 service 服务的公共配置类，所有 service 模块依赖于它
  - **spring-security**：认证与授权模块，需要认证授权的 service 服务依赖于它

- **infrastructure**：基础服务模块父节点。

  - **api-gateway**：api网关服务

- **service**：api 接口服务的父节点，包含项目主要的微服务模块

  <br>

##### 创建父工程

###### 第一步

在 idea 开发工具中，使用 Spring Initializr 快速初始化一个 Spring Boot 模块。

###### 第二步

删除 src 目录。

###### 第三步

在 artifactId 接口后将打包类型设置为 pom（默认为 pom，一般不需要设置）。

```
<artifactId>xxx</artifactId>
<packaging>pom</packaging>
```

###### 第四步

删除 pom.xml 中的 \<dependencies> 内容：

```
    <!-- 以下内容删除 -->
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
```

###### 第五步

修改配置文件：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <modules>
        <module>service</module>
    </modules>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.3.12.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>cn.nilnullnaught</groupId>
    <artifactId>nnnnote</artifactId>
    <packaging>pom</packaging>
    <version>0.0.1-SNAPSHOT</version>
    <name>nnnnote</name>
    <description>nnnnote</description>

    <properties>
        <java.version>11</java.version>
        <nnnnnote.version>0.0.1-SNAPSHOT</nnnnnote.version>
        <cloud-alibaba.version>2.2.7.RELEASE</cloud-alibaba.version>
        <mybatis-plus.version>3.5.0</mybatis-plus.version>
        <velocity.version>2.0</velocity.version>
        <springdoc-openapi-ui.version>1.6.4</springdoc-openapi-ui.version>
        <jjwt.version>0.7.0</jjwt.version>
        <commons-dbutils.version>1.7</commons-dbutils.version>
        <commons-fileupload.version>1.3.1</commons-fileupload.version>
        <commons-io.version>2.6</commons-io.version>
        <httpclient.version>4.5.1</httpclient.version>
        <canal.client.version>1.1.0</canal.client.version>
        <docker.image.prefix>zx</docker.image.prefix>
        <junit.version>4.12</junit.version>

        <aliyun.oss.version>2.8.3</aliyun.oss.version>
        <aliyun-java-sdk-core.version>4.3.3</aliyun-java-sdk-core.version>
        <aliyun-sdk-oss.version>3.1.0</aliyun-sdk-oss.version>
        <aliyun-java-sdk-vod.version>2.15.2</aliyun-java-sdk-vod.version>
        <aliyun-java-vod-upload.version>1.4.11</aliyun-java-vod-upload.version>
        <aliyun-sdk-vod-upload.version>1.4.11</aliyun-sdk-vod-upload.version>
        <fastjson.version>1.2.28</fastjson.version>
        <gson.version>2.8.2</gson.version>
        <json.version>20170516</json.version>

        <jodatime.version>2.10.1</jodatime.version>
        <poi.version>3.17</poi.version>
    </properties>


    <dependencyManagement>
        <dependencies>
            <!--Spring Cloud-->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Hoxton.SR12</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>${cloud-alibaba.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!--mybatis-plus 持久层-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>${mybatis-plus.version}</version>
            </dependency>

            <!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 -->
            <dependency>
                <groupId>org.apache.velocity</groupId>
                <artifactId>velocity-engine-core</artifactId>
                <version>${velocity.version}</version>
            </dependency>

            <!-- springdoc，帮助使用者将 swagger3 集成到 Spring 中 -->
            <dependency>
                <groupId>org.springdoc</groupId>
                <artifactId>springdoc-openapi-ui</artifactId>
                <version>${springdoc-openapi-ui.version}</version>
            </dependency>

            <!-- java JWT -->
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt</artifactId>
                <version>${jjwt.version}</version>
            </dependency>

            <!--commons-dbutils-->
            <dependency>
                <groupId>commons-dbutils</groupId>
                <artifactId>commons-dbutils</artifactId>
                <version>${commons-dbutils.version}</version>
            </dependency>

            <!--文件上传-->
            <dependency>
                <groupId>commons-fileupload</groupId>
                <artifactId>commons-fileupload</artifactId>
                <version>${commons-fileupload.version}</version>
            </dependency>

            <!--commons-io-->
            <dependency>
                <groupId>commons-io</groupId>
                <artifactId>commons-io</artifactId>
                <version>${commons-io.version}</version>
            </dependency>

            <!--httpclient-->
            <dependency>
                <groupId>org.apache.httpcomponents</groupId>
                <artifactId>httpclient</artifactId>
                <version>${httpclient.version}</version>
            </dependency>

            <!-- canal -->
            <dependency>
                <groupId>com.alibaba.otter</groupId>
                <artifactId>canal.client</artifactId>
                <version>${canal.client.version}</version>
            </dependency>

            <!-- junit -->
            <dependency>
                <groupId>junit</groupId>
                <artifactId>junit</artifactId>
                <version>${junit.version}</version>
            </dependency>



            <!--aliyunOSS-->
            <dependency>
                <groupId>com.aliyun.oss</groupId>
                <artifactId>aliyun-sdk-oss</artifactId>
                <version>${aliyun.oss.version}</version>
            </dependency>
            <!--aliyun-->
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>aliyun-java-sdk-core</artifactId>
                <version>${aliyun-java-sdk-core.version}</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun.oss</groupId>
                <artifactId>aliyun-sdk-oss</artifactId>
                <version>${aliyun-sdk-oss.version}</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>aliyun-java-sdk-vod</artifactId>
                <version>${aliyun-java-sdk-vod.version}</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>aliyun-java-vod-upload</artifactId>
                <version>${aliyun-java-vod-upload.version}</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>aliyun-sdk-vod-upload</artifactId>
                <version>${aliyun-sdk-vod-upload.version}</version>
            </dependency>
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>${fastjson.version}</version>
            </dependency>
            <dependency>
                <groupId>org.json</groupId>
                <artifactId>json</artifactId>
                <version>${json.version}</version>
            </dependency>
            <dependency>
                <groupId>com.google.code.gson</groupId>
                <artifactId>gson</artifactId>
                <version>${gson.version}</version>
            </dependency>


            <!--日期时间工具-->
            <dependency>
                <groupId>joda-time</groupId>
                <artifactId>joda-time</artifactId>
                <version>${jodatime.version}</version>
            </dependency>
            <!--xls-->
            <dependency>
                <groupId>org.apache.poi</groupId>
                <artifactId>poi</artifactId>
                <version>${poi.version}</version>
            </dependency>
            <!--xlsx-->
            <dependency>
                <groupId>org.apache.poi</groupId>
                <artifactId>poi-ooxml</artifactId>
                <version>${poi.version}</version>
            </dependency>
        </dependencies>


    </dependencyManagement>

    <build>
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.xml</include>
                </includes>
                <filtering>false</filtering>
            </resource>
        </resources>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```

<br>

##### 创建 service 模块

###### 第一步

在父工程下创建子模块 service，选择 maven 类型。

###### 第二步

将 service 模块的打包类型设置为 pom，即在 \<artifactId> 节点后添加以下属性：

```
	...
	
    <artifactId>service</artifactId>
    <!-- 将打包类型设置为 pom -->
    <packaging>pom</packaging>
	...
```

###### 第三步

在 service 模块的 pom.xml 文件下添加各个微服务子模块的公共依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
    </dependency>

    <!--hystrix依赖，主要是用  @HystrixCommand -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
    </dependency>

    <!--服务注册-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    <!--服务调用-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-openfeign</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!--mybatis-plus-->
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
    </dependency>

    <!--mysql-->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>

    <!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 -->
    <dependency>
        <groupId>org.apache.velocity</groupId>
        <artifactId>velocity-engine-core</artifactId>
    </dependency>

    <!-- springdoc，帮助使用者将 swagger3 集成到 Spring 中 -->
    <dependency>
		<groupId>org.springdoc</groupId>
		<artifactId>springdoc-openapi-ui</artifactId>
    </dependency>

    <!--xls-->
    <dependency>
        <groupId>org.apache.poi</groupId>
        <artifactId>poi</artifactId>
    </dependency>

    <dependency>
        <groupId>org.apache.poi</groupId>
        <artifactId>poi-ooxml</artifactId>
    </dependency>

    <dependency>
        <groupId>commons-fileupload</groupId>
        <artifactId>commons-fileupload</artifactId>
    </dependency>

    <!--httpclient-->
    <dependency>
        <groupId>org.apache.httpcomponents</groupId>
        <artifactId>httpclient</artifactId>
    </dependency>
    
    <!--commons-io-->
    <dependency>
        <groupId>commons-io</groupId>
        <artifactId>commons-io</artifactId>
    </dependency>
   

    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
    </dependency>
</dependencies>
```

<br>

##### 在 Service 下创建微服务子模块

###### 创建微服务子模块

在 service 模块下创建 service 子模块 service-module，选择 maven 类型。

###### 配置文件

application.yml

```yaml
server:
  port: 8001 #配置端口号

# mybatis-plus 配置
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # mybatis-plus 日志
  mapper-locations: classpath:cn/nilnullnaught/service/*/mapper/*.xml
  global-config:
    db-config:
      logic-delete-value: 1
      logic-not-delete-value: 0

spring:
  application:
    name: service-test #配置服务名
  #数据库配置
  datasource:
    type: com.zaxxer.hikari.HikariDataSource #使用 Hikari 数据库连接池
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://8.131.72.52:3306/shirotest?useSSL=false&serverTimezone=Asia/Shanghai&allowMultiQueries=true
    username: Outsider
    password: PASSWORDis1024
    hikari:
      minimum-idle: 10  
      maximum-pool-size: 100
      auto-commit: true
      idle-timeout: 30000
      pool-name: NNNnoteHikariPool
      max-lifetime: 180000
      connection-timeout: 30000
      connection-test-query: SELECT 1
      time-zone: GMT+8
  # redis 配置
  redis:
    host: 8.131.72.52
    port: 6379
    password: PASSWORDis1024
    database: 0
    lettuce:
      pool:
        max-active: 20
        max-wait: -1
        max-idle: 8
        min-idle: 0
      shutdown-timeout: 100
    timeout: 10000
  # 统一返回的 json 时间格式
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8 #默认情况下json时间格式带有时区，并且是世界标准时间，和我们的时间差了八个小时
```

###### 创建 SpringBoot 启动类

```java
package cn.nilnullnaught.nnnnote.user;

@SpringBootApplication
//springboot 项目启动时，如果没有配置数据库配置，启动时会抛出异常，

//如果该模块不需要使用数据库，那么使用以下配置防止异常出现
	//spring boot 会默认加载org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration 这个类，
	//而 DataSourceAutoConfiguration 类使用了 @Configuration 注解向 spring 注入了 dataSource bean，
	//又因为项目（oss模块）中并没有关于 dataSource 相关的配置信息，所以当 spring 创建 dataSource bean 时因缺少相关的信息就会报错。
//@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)

@ComponentScan("cn.nilnullnaught.nnnnote")
@EnableFeignClients //开启 Feign 功能
@MapperScan("cn.nilnullnaught.nnnnote.user.mapper")
//spring cloud 从 Edgware 版本开始，只要配置好注册中心的相关配置即可自动开启服务注册功能
//@EnableDiscoveryClient
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
}
```

<br>

<br>

##### 创建 common 模块

###### 第一步

在父工程下创建 maven 模块 common。

###### 第二步

在 common 中引入依赖：

```xml
<dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <scope>provided </scope>
        </dependency>

        <!--mybatis-plus-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <scope>provided </scope>
        </dependency>

        <!--lombok用来简化实体类：需要安装lombok插件-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <scope>provided</scope>
        </dependency>

    <!-- springdoc，帮助使用者将 swagger3 集成到 Spring 中 -->
    <dependency>
		<groupId>org.springdoc</groupId>
		<artifactId>springdoc-openapi-ui</artifactId>
    </dependency>

        <!-- redis -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>

        <!-- spring2.X集成redis所需common-pool2
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
            <version>2.6.0</version>
        </dependency>-->
    </dependencies>

	<!-- 对于没有 main() 的工具包（比如 common 包），打包时会出现 Unable to find main class 错误， 需要在 pom.xml 文件中加入以下配置 -->
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>2.3.2.RELEASE</version>
                <configuration>
                    <layout>NONE</layout>
                </configuration>
            </plugin>
        </plugins>
    </build>
```

<br>

##### 创建 common 的子模块 service-base

在该模块下创建包 cn.nilnullnaught.servicebase

<br>

##### 创建 common 的子模块 common-utils

在该模块下创建包 cn.nilnullnaught.commonutils

<br>

#### 📌解决 Mybatis 的 xml 文件不能随着编译自动生成问题

###### 原因

默认情况下，maven 工程在 src/main/java 目录下的所有资源文件是不发布到 target 目录下的。

###### 解决方案一

1. 在父工程的 pom.xml 文件中配置如下节点：

```
<!-- 项目打包时会将java目录中的*.xml文件也进行打包 -->
<build>
    <resources>
        <resource>
            <directory>src/main/java</directory>
            <includes>
                <include>**/*.xml</include>
            </includes>
            <filtering>false</filtering>
        </resource>
    </resources>
</build>
```

2. 在 Spring Boot 配置文件中添加配置

```
#配置mapper xml文件的路径
mybatis-plus.mapper-locations=classpath:cn/nilnullnaught/*/mapper/xml/*.xml
```

<br>


---

<div STYLE="page-break-after: always;">
    <br>
	<br>
	<br>
	<br>
	<br>
</div>
## 2	使用代码生成器

### 2.1	Mybatisplus 代码生成器（旧）

##### 创建代码生成器

###### 前提条件

已经导入 mybatisplus 依赖。

###### 生成器代码

在 test/java 目录下创建包com.atguigu.eduservice，创建代码生成器：`CodeGenerator.java`

```java
package cn.nilnullnaught.eduservice;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.DataSourceConfig;
import com.baomidou.mybatisplus.generator.config.GlobalConfig;
import com.baomidou.mybatisplus.generator.config.PackageConfig;
import com.baomidou.mybatisplus.generator.config.StrategyConfig;
import com.baomidou.mybatisplus.generator.config.rules.DateType;
import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;
import org.junit.Test;

public class CodeGenerator {
    public class getCode {
        @Test
        public void main1() {
            // 1、创建代码生成器
            AutoGenerator mpg = new AutoGenerator();
            // 2、全局配置
            GlobalConfig gc = new GlobalConfig();
            String projectPath = System.getProperty("user.dir");
            System.out.println(projectPath);
            //建议修改，将 projectPath 手动替换为项目的绝对路径
            gc.setOutputDir(projectPath + "/src/main/java");
            //需要修改，数据表名
            gc.setAuthor("");
            gc.setOpen(false); //生成后是否打开资源管理器
            gc.setFileOverride(false); //重新生成时文件是否覆盖
            /*
             * mp生成service层代码，默认接口名称第一个字母有 I
             * UcenterService
             * */
            gc.setServiceName("%sService"); //去掉Service接口的首字母I
            gc.setIdType(IdType.ID_WORKER); //主键策略
            gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型
            gc.setSwagger2(true);//开启Swagger2模式
            mpg.setGlobalConfig(gc);
            // 3、数据源配置
            DataSourceConfig dsc = new DataSourceConfig();
            //需要修改，数据库 url
            dsc.setUrl("jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8");
            dsc.setDriverName("com.mysql.cj.jdbc.Driver");
            //需要修改，数据库访问名
            dsc.setUsername("root");
            //需要修改，数据库密码
            dsc.setPassword("root");
            dsc.setDbType(DbType.MYSQL);
            mpg.setDataSource(dsc);
            // 4、包配置
            PackageConfig pc = new PackageConfig();
            //需要修改，模块名
            pc.setModuleName("serviceedu"); 
            //需要修改，组织名
            pc.setParent("cn.nilnullnaught");
            pc.setController("controller");
            pc.setEntity("entity");
            pc.setService("service");
            pc.setMapper("mapper");
            mpg.setPackageInfo(pc);
            // 5、策略配置
            StrategyConfig strategy = new StrategyConfig();
            //需要修改，数据表名
            strategy.setInclude("edu_teacher");
            strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略
            strategy.setTablePrefix(pc.getModuleName() + "_"); //生成实体时去掉表前缀
            strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略
            strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作
            strategy.setRestControllerStyle(true); //restful api风格控制器
            strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符
            mpg.setStrategy(strategy);
            // 6、执行
            mpg.execute();
        }
    }
}

```

<br>

---

<div STYLE="page-break-after: always;">
    <br>
	<br>
	<br>
	<br>
	<br>
</div>
### 2.2	Mybatisplus 代码生成器（3.5.1版）

##### 步骤

###### 第一步

引入依赖：

```
            <!--mybatis-plus -->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>${mybatis-plus.version}</version>
            </dependency>
            <!--mybatis-plus代码生成器-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-generator</artifactId>
                <version>${mybatis-plus-generator.version}</version>
            </dependency>
            <!-- freemarker 模板引擎，mybatis-plus 代码生成器（3.5.1 版本需要）-->
            <dependency>
                <groupId>org.freemarker</groupId>
                <artifactId>freemarker</artifactId>
                <version>${freemarker.version}</version>
            </dependency>
```

###### 第二步

在 test 中创建方法

```java
    @Test
    public void main1() {
        String url = "";
        String username = "";
        String password = "";
        // 设置作者
        String author = "";
        // 指定输出目录
        String outputDir = System.getProperty("user.dir")+"/src/main/java";
        // 设置父包名
        String parent = "";
        //设置父包模块名
        String moduleName = "";
        //设置mapperXml生成路径
        String mapperXmlDir = "";
        // 设置需要生成的表名
        String[] tables = {"user_message"};
        // 设置过滤表前缀
        String[] removePrefix = {"t_", "c_"};

        FastAutoGenerator.create(url, username, password)
                .globalConfig(builder -> {
                    builder.author(author) // 设置作者
                            .enableSwagger() // 开启 swagger 模式
                            .fileOverride() // 覆盖已生成文件
                            .outputDir(outputDir); // 指定输出目录
                })
                .packageConfig(builder -> {
                    builder.parent(parent) // 设置父包名
                            .moduleName(moduleName) // 设置父包模块名
                            .pathInfo(Collections.singletonMap(OutputFile.mapperXml, mapperXmlDir)); // 设置mapperXml生成路径
                })
                .strategyConfig(builder -> {
                    builder.addInclude(tables) // 设置需要生成的表名
                            .addTablePrefix(removePrefix) // 设置过滤表前缀
                            .entityBuilder() // Entity 策略配置
                                .enableLombok() // 开启 Lombok
                            .controllerBuilder() // Controller 策略配置
                                .enableRestStyle() // 开启生成@RestController 控制器
                            .serviceBuilder() // Service 策略配置
                                .formatServiceFileName("%sService") // 去掉字母 I
                                .formatServiceImplFileName("%sServiceImpl")
                            .mapperBuilder() // Mapper 策略配置
                                .enableMapperAnnotation(); // 开启 @Mapper 注解
                })
                .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板(需要导包)，默认的是Velocity引擎模板
                .execute();
    }
```

<br>

---

<div STYLE="page-break-after: always;">
    <br>
	<br>
	<br>
	<br>
	<br>
</div>

## 3	配置 Swagger

### 3.1	配置 Swagger 2

##### 注意

1. Spring Boot 后续版本默认集成了 Swagger，不需要导入 Swagger依赖，但是其他版本需要。

2. 整合权限框架（比如 Spring Security、Shiro）后，需要对 swagger 相关路径放行：

   ```java
   // 以 Spring Security 为例
   //Swagger 2 需要排除的路径有以下：
   registry.addInterceptor(new SaRouteInterceptor())
   .addPathPatterns("/**")
   .excludePathPatterns(
   "/swagger-ui/**",
   "/swagger-resources/**",
   "/webjars/**",
   "/v2/api-docs");
   
   //Swagger 3 需要排除的路径有以下：
   registry.addInterceptor(new SaRouteInterceptor())
   .addPathPatterns("/**")
   .excludePathPatterns(
   "/swagger-ui/**",
   "/swagger-resources/**",
   "/webjars/**",
   "/v3/api-docs");
   ```

<br>

##### 配置

###### 第一步

在 common > service-base 中创建 config 包，并创建swagger 的配置类

```java
package cn.nilnullnaught.servicebase.config;

import com.google.common.base.Predicates;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration
@EnableSwagger2
public class SwaggerConfig {

    @Bean
    public Docket webApiConfig(){

        return new Docket(DocumentationType.SWAGGER_2)
                .groupName("webApi")
                .apiInfo(webApiInfo())
                .select()
                .paths(Predicates.not(PathSelectors.regex("/admin/.*")))
                .paths(Predicates.not(PathSelectors.regex("/error.*")))
                .build();

    }

    private ApiInfo webApiInfo(){

        return new ApiInfoBuilder()
                .title("网站-课程中心 API 文档")
                .description("本文档描述了课程中心微服务接口定义")
                .version("1.0")
                .contact(new Contact("java", "http://atguigu.com", "55317332@qq.com"))
                .build();
    }
}
```

###### 第二步

在 service 模块中引入 service-base

```xml
        <!--引入 service-base 模块-->
        <dependency>
            <groupId>cn.nilnullnaught</groupId>
            <artifactId>service-base</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
```

###### 第三步

在微服务子模块（如 service-edu ）的启动类上添加注解：

```java
@@SpringBootApplication
@ComponentScan(basePackages = {"cn.nilnullnaught"})
public class EduApplication {

    public static void main(String[] args) {
        SpringApplication.run(EduApplication.class, args);
    }
}
```

###### 第四步

开启微服务，打开 `【IP 地址】:【服务端口】/swagger-ui.html`。

<br>

##### 定义接口说明和参数说明

- @Api：定义在类上。
- @ApiOperation：定义在方法上。
- @ApiParam：定义在参数上。

示例代码：

```java
Api(description="讲师管理")
@RestController
@RequestMapping("/admin/edu/teacher")
public class TeacherAdminController {

	@Autowired
	private TeacherService teacherService;

	@ApiOperation(value = "所有讲师列表")
	@GetMapping
	public List<Teacher> list(){
		return teacherService.list(null);
	}

	@ApiOperation(value = "根据ID删除讲师")
	@DeleteMapping("{id}")
	public boolean removeById(
			@ApiParam(name = "id", value = "讲师ID", required = true)
			@PathVariable String id){
		return teacherService.removeById(id);
	}
}
```

<br>

---

<div STYLE="page-break-after: always;">
    <br>
	<br>
	<br>
	<br>
	<br>
</div>
### 3.2	❌（存在问题）配置 Swagger3

##### springdoc官网

https://springdoc.org/

<br>

##### swagger2与swagger3注解对照

注意：swagger3注解在 io.swagger.v3.oas.annotations 包中，不要导错

| swagger2                                    | swagger3                                                     |
| ------------------------------------------- | ------------------------------------------------------------ |
| @Api                                        | @Tag                                                         |
| @ApiIgnore                                  | @Parameter(hidden = true) 或 @Operation(hidden = true) 或 @Hidden |
| @ApiImplicitParam                           | @Parameter                                                   |
| @ApiImplicitParams                          | @Parameters                                                  |
| @ApiModel                                   | @Schema                                                      |
| @ApiModelProperty(hidden = true)            | @Schema(accessMode = Schema.AccessMode.READ_ONLY)            |
| @ApiModelProperty                           | @Schema                                                      |
| @ApiOperation(value = “foo”, notes = “bar”) | @Operation(summary = “foo”, description = “bar”)             |
| @ApiParam                                   | @Parameter                                                   |
| @ApiResponse(code = 404, message = “foo”)   | @ApiResponse(responseCode = “404”, description = “foo”)      |

<br>

##### maven依赖

```
<dependency>
   <groupId>org.springdoc</groupId>
   <artifactId>springdoc-openapi-ui</artifactId>
   <version>1.5.3</version>
</dependency>
```

<br>

##### swagger3的开启和关闭

application.yml：

```
springdoc:
  api-docs:
    enabled: true #默认为true开启
```

<br>

##### swagger3 的配置类

```
import org.springdoc.core.GroupedOpenApi;
import org.springdoc.core.customizers.OperationCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.method.HandlerMethod;

import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.models.ExternalDocumentation;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.Operation;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.media.StringSchema;
import io.swagger.v3.oas.models.parameters.Parameter;

@Configuration
public class Swagger3Config {
	
	//配置一个test-public组
	@Bean
	public GroupedOpenApi publicApi() {
		return GroupedOpenApi.builder()
				.group("test-public")
				.packagesToScan("com.szh.demo.material")
//				.pathsToMatch("/material/**")
				.addOperationCustomizer(operationCustomizer())
				.build();
	}
	//配置其他组
	@Bean
	public GroupedOpenApi otherApi() {
		return GroupedOpenApi.builder()
				.group("test-other")
				.packagesToScan("com.szh.demo.other")
//				.pathsToMatch("/other/**")
				.build();
	}
	
	/**
	 * 给所有@Operation注释的接口添加一个tellerno请求头参数
	 * @return
	 */
	@Bean
	public OperationCustomizer operationCustomizer () {
		return new OperationCustomizer() {
			
			@Override
			public Operation customize(Operation operation, HandlerMethod handlerMethod) {
				operation.addParametersItem(
						new Parameter()
						.in(ParameterIn.HEADER.toString())
						.name("tellerno")
						.description("登录用户账号")
						.schema(new StringSchema())
						.required(false)
						);
				return operation;
			}
		};
	}
	
	@Bean
	public OpenAPI openAPI() {
		return new OpenAPI()
	              .info(new Info().title("Swagger3 test API")
	              .description("Swagger3 test sample application")
	              .version("v1.0.0")
	              .license(new License().name("Apache 2.0").url("http://springdoc.org")))
	              .externalDocs(new ExternalDocumentation()
	              .description("SpringShop Wiki Documentation")
	              .url("https://springshop.wiki.github.org/docs"));
    }
    
}
```

<br>

##### Swagger UI默认访问地址

http://server:port/context-path/swagger-ui.html

<br>

---

<div STYLE="page-break-after: always;">
    <br>
	<br>
	<br>
	<br>
	<br>
</div>

## 4	统一返回数据格式

##### 统一返回数据格式的作用

项目中我们会将响应封装成 json 返回，所以一般我们会将所有接口的数据格式统一， 使前端（iOS Android, Web）对数据的操作更一致、轻松。

<br>

##### 统一返回数据格式的需求

一般情况下，统一返回数据格式没有固定的格式，只要能描述清楚返回的数据状态以及要返回的具体数据就可以。但是一般会包含状态码、返回消息、数据这几部分内容

例如，我们的系统要求返回的基本数据格式如下：

**列表：**

```
{
  "success": true,
  "code": 20000,
  "message": "成功",
  "data": {
    "items": [
      {
        "id": "1",
        "name": "刘德华",
        "intro": "毕业于师范大学数学系，热爱教育事业，执教数学思维6年有余"
      }
    ]
  }
}
```

**分页：**

```
{
  "success": true,
  "code": 20000,
  "message": "成功",
  "data": {
    "total": 17,
    "rows": [
      {
        "id": "1",
        "name": "刘德华",
        "intro": "毕业于师范大学数学系，热爱教育事业，执教数学思维6年有余"
      }
    ]
  }
}
```

**没有返回数据：**

```
{
  "success": true,
  "code": 20000,
  "message": "成功",
  "data": {}
}
```

**失败：**

```
{
  "success": false,
  "code": 20001,
  "message": "失败",
  "data": {}
}
```

因此，我们定义统一结果：

```
{
  "success": 布尔, //响应是否成功
  "code": 数字, //响应码
  "message": 字符串, //返回消息
  "data": HashMap //返回数据，放在键值对中
}
```

<br>

##### 实现统一返回数据格式

###### 第一步

在 common-utils 的 cn.nilnullnaught.commonutils 包下创建接口，定义返回码（也可以通过枚举方式实现）：

```java
public interface ResultCode {

    public static Integer SUCCESS = 20000;

    public static Integer ERROR = 20001;
}
```

###### 第二步

在 common-utils 的 cn.nilnullnaught.commonutils 包下创建结果类：

```java
@Data
public class R {
    @ApiModelProperty(value = "是否成功")
    private Boolean success;

    @ApiModelProperty(value = "返回码")
    private Integer code;

    @ApiModelProperty(value = "返回消息")
    private String message;

    @ApiModelProperty(value = "返回数据")
    private Map<String, Object> data = new HashMap<String, Object>();

    private R(){}

    public static R ok(){
        R r = new R();
        r.setSuccess(true);
        r.setCode(ResultCode.SUCCESS);
        r.setMessage("成功");
        return r;
    }

    public static R error(){
        R r = new R();
        r.setSuccess(false);
        r.setCode(ResultCode.ERROR);
        r.setMessage("失败");
        return r;
    }

    public R success(Boolean success){
        this.setSuccess(success);
        return this;
    }

    public R message(String message){
        this.setMessage(message);
        return this;
    }

    public R code(Integer code){
        this.setCode(code);
        return this;
    }

    public R data(String key, Object value){
        this.data.put(key, value);
        return this;
    }

    public R data(Map<String, Object> map){
        this.setData(map);
        return this;
    }
```

<br>

##### 使用统一返回结果

###### 第一步

在 service 模块中添加 commonutils 依赖

```xml
        <dependency>
            <groupId>cn.nilnullnaught</groupId>
            <artifactId>common-utils</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
```

###### 第二步

修改 Controller 中的返回结果

```java
@GetMapping
public R list(){
    List<Object> list = objectService.list(null);
    return R.ok().data("items", list);
}
```



---

<div STYLE="page-break-after: always;">
    <br>
	<br>
	<br>
	<br>
	<br>
</div>
## 5	统一异常处理

##### 什么是统一异常处理

让异常结果也显示为统一的返回结果对象，并且统一处理系统的异常信息，那么需要统一异常处理

<br>

##### @ControllerAdvice 

拦截所有的以 `@Controller` 为注解的类，以及他们的子类进行异常处理。

<br>

##### @ExceptionHandler(Throwable.class)

该注解用于指定需要处理的异常类型。

<br>

##### 基本实现步骤

###### 第一步

在 service-base 中创建 exceptionhandler 包，在该包下创建统一异常处理类 GlobalExceptionHandler.java：

```java
/**
 * 统一异常处理类
 */
@ControllerAdvice
public class GlobalExceptionHandler {

	@ExceptionHandler(Exception.class)
	@ResponseBody
	public R error(Exception e){
		e.printStackTrace();
		return R.error();
	}
}
```

###### 第二步

在controller 中添加方法，人为制造异常进行测试：

```java
    @ApiOperation(value = "统一异常处理测试")
    @GetMapping("/test")
    public ResponseResult test(){
        int i = 1/0;
        return ResponseResult.ok();
    }
```

<br>

##### 处理特定异常

###### 第一步

在 GlobalExceptionHandler.java 中添加异常处理方法：

```java
    @ExceptionHandler(ArithmeticException.class)
    @ResponseBody
    public ResponseResult error(ArithmeticException e){
        e.printStackTrace();
        return ResponseResult.error().message("执行了自定义异常");
    }
```

###### 第二步

进行测试。

<br>

##### 自定义异常

###### 第一步

在 service-base 的 exceptionhandler 该包下创建自定义异常类：

```java
@Data
@AllArgsConstructor
@NoArgsConstructor


//自定义异常应该 并继承于java.lang.RuntimeException（表示可处理可不处理）
//这样在抛出异常时就无需增加额外 throws 或 try{}catch(){} d
public class EduException extends RuntimeException {

    @ApiModelProperty(value = "状态码")
    private Integer code;
    
	@ApiModelProperty(value = "异常信息")
    private String message;
}
```

###### 第二步

在业务中需要的位置抛出 EduException

```java
try {
    int a = 10/0;
}catch(Exception e) {
    throw new EduException(20001,"出现自定义异常");
}
```

###### 第三步

在 GlobalExceptionHandler.java 中添加异常处理方法：

```
@ExceptionHandler(GuliException.class)
@ResponseBody
public ResponseResult error(GuliException e){
    e.printStackTrace();
    return ResponseResult.error().message(e.getMsg()).code(e.getCode());
}
```

###### 第四步

测试。

<br>

---

<div STYLE="page-break-after: always;">
    <br>
	<br>
	<br>
	<br>
	<br>
</div>

## 6	统一日志处理

##### 日志级别

日志记录器（Logger）的行为是分等级的，分为：

- OFF
- FATAL
- ERROR
- WARN
- INFO
- DEBUG
- ALL

默认情况下，spring boot 从控制台打印出来的日志级别只有 INFO 及以上级别。

<br>

##### 在配置文件中配置日志级别

```
# 设置日志级别
logging.level.root=WARN
```

注意，这种方式只能将日志打印在控制台上，无法持久化。

<br>

##### Logback 日志

spring boot 内部使用 Logback 作为日志实现的框架。Logback 和 log4j 非常相似，如果你对 log4j 很熟悉，那对 logback 很快就会得心应手。

###### logback 相对于 log4j 的一些优点

https://blog.csdn.net/caisini_vc/article/details/48551287

<br>

##### 配置 logback 日志

###### 第一步

导入依赖：

```xml
            <!-- locback -->
            <dependency>
                <groupId>ch.qos.logback</groupId>
                <artifactId>logback-classic</artifactId>
                <version>${logback-classic.version}</version>
            </dependency>
            <!-- slf4j -->
            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-api</artifactId>
                <version>${slf4j-api.version}</version>
            </dependency>
```

###### 第二步

安装idea彩色日志插件：grep-console。

###### 第三步

在 resources 中创建 logback-spring.xml：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration  scan="true" scanPeriod="10 seconds">
    <!-- 日志级别从低到高分为TRACE < DEBUG < INFO < WARN < ERROR < FATAL，如果设置为WARN，则低于WARN的信息都不会输出 -->
    <!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true -->
    <!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 -->
    <!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 -->

    <contextName>logback</contextName>
    <!-- name的值是变量的名称，value的值是变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。 -->
    <property name="log.path" value="D://log" />

    <!-- 彩色日志 -->
    <!-- 配置格式变量：CONSOLE_LOG_PATTERN 彩色日志格式 -->
    <!-- magenta:洋红 -->
    <!-- boldMagenta:粗红-->
    <!-- cyan:青色 -->
    <!-- white:白色 -->
    <!-- magenta:洋红 -->
    <property name="CONSOLE_LOG_PATTERN"
              value="%yellow(%date{yyyy-MM-dd HH:mm:ss}) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)"/>


    <!--输出到控制台-->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息-->
        <!-- 例如：如果此处配置了INFO级别，则后面其他位置即使配置了 DEBUG 级别的日志，也不会被输出 -->
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <!--<level>INFO</level>-->
            <level>DEBUG</level>
        </filter>
        <encoder>
            <Pattern>${CONSOLE_LOG_PATTERN}</Pattern>
            <!-- 设置字符集 -->
            <charset>UTF-8</charset>
        </encoder>
    </appender>


    <!--输出到文件-->

    <!-- 时间滚动输出 level为 INFO 日志 -->
    <appender name="INFO_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 正在记录的日志文件的路径及文件名 -->
        <file>${log.path}/log_info.log</file>
        <!--日志文件输出格式-->
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 每天日志归档路径以及格式 -->
            <fileNamePattern>${log.path}/info/log-info-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文件保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
        <!-- 此日志文件只记录info级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>INFO</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!-- 时间滚动输出 level为 WARN 日志 -->
    <appender name="WARN_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 正在记录的日志文件的路径及文件名 -->
        <file>${log.path}/log_warn.log</file>
        <!--日志文件输出格式-->
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset> <!-- 此处设置字符集 -->
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${log.path}/warn/log-warn-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文件保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
        <!-- 此日志文件只记录warn级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>warn</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>


    <!-- 时间滚动输出 level为 ERROR 日志 -->
    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 正在记录的日志文件的路径及文件名 -->
        <file>${log.path}/log_error.log</file>
        <!--日志文件输出格式-->
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset> <!-- 此处设置字符集 -->
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${log.path}/error/log-error-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文件保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
        <!-- 此日志文件只记录ERROR级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!--
        <logger>用来设置某一个包或者具体的某一个类的日志打印级别、以及指定<appender>。
        <logger>仅有一个name属性，
        一个可选的level和一个可选的addtivity属性。
        name:用来指定受此logger约束的某一个包或者具体的某一个类。
        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，
              如果未设置此属性，那么当前logger将会继承上级的级别。
    -->
    <!--
        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：
        第一种把<root level="INFO">改成<root level="DEBUG">这样就会打印sql，不过这样日志那边会出现很多其他消息
        第二种就是单独给mapper下目录配置DEBUG模式，代码如下，这样配置sql语句会打印，其他还是正常DEBUG级别：
     -->
    <!--开发环境:打印控制台-->
    <springProfile name="dev">
        <!--可以输出项目中的debug日志，包括mybatis的sql日志-->
        <logger name="cn.nilnullnaught.nnnnote" level="DEBUG" />

        <!--
            root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性
            level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，默认是DEBUG
            可以包含零个或多个appender元素。
        -->
        <root level="INFO">
            <appender-ref ref="CONSOLE" />
            <appender-ref ref="INFO_FILE" />
            <appender-ref ref="WARN_FILE" />
            <appender-ref ref="ERROR_FILE" />
        </root>
    </springProfile>


    <!--生产环境:输出到文件-->
    <springProfile name="pro">

        <root level="INFO">
            <appender-ref ref="CONSOLE" />
            <appender-ref ref="DEBUG_FILE" />
            <appender-ref ref="INFO_FILE" />
            <appender-ref ref="ERROR_FILE" />
            <appender-ref ref="WARN_FILE" />
        </root>
    </springProfile>

</configuration>
```

###### 第四步

将错误日志输出到文件，在 GlobalExceptionHandler.java 中添加注解 `@Slf4j`（如果不想每次都写 `private final Logger logger = LoggerFactory.getLogger(当前类名.class);` 可以用`@Slf4`j），与异常输出语句 `log.error(e.getMessage());`：

```java
@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    @ResponseBody
    public R error(Exception e){
        log.error(e.getMessage());
        e.printStackTrace();
        return R.error();
    }
}
```

<br>

##### 将日志堆栈信息输出到文件

###### 第一步

在 common-utils 下创建 util 包，创建 ExceptionUtil.java 工具类：

```
package com.guli.common.util;

public class ExceptionUtil {

	public static String getMessage(Exception e) {
		StringWriter sw = null;
		PrintWriter pw = null;
		try {
			sw = new StringWriter();
			pw = new PrintWriter(sw);
			// 将出错的栈信息输出到printWriter中
			e.printStackTrace(pw);
			pw.flush();
			sw.flush();
		} finally {
			if (sw != null) {
				try {
					sw.close();
				} catch (IOException e1) {
					e1.printStackTrace();
				}
			}
			if (pw != null) {
				pw.close();
			}
		}
		return sw.toString();
	}
}
```

###### 第二步

在自定义异常类中创建 toString() 方法

```
@Data
@AllArgsConstructor
@NoArgsConstructor
public class MyException {

    @ApiModelProperty(value = "状态码")
    private Integer code;

    @ApiModelProperty(value = "异常提示信息")
    private String message;

    @Override
    public String toString() {
        return "EduException{" +
                "message=" + this.getMessage() +
                ", code=" + code +
                '}';
    }
}
```

###### 第三步

在 GlobalExceptionHandler.java 中的异常处理方法中调用：

```java
@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    @ResponseBody
    public R error(Exception e){
        log.error(ExceptionUtil.getMessage(e));
        log.error(e.getMessage());
        e.printStackTrace();
        return R.error();
    }
}
```

<br>

---

<div STYLE="page-break-after: always;">
    <br>
	<br>
	<br>
	<br>
	<br>
</div>

## 8	常用功能实现

### 8.1	逻辑删除

##### 实现步骤

###### 第一步

在配置文件中开启逻辑删除（已完成）。

###### 第二步

在 MyBatisPlusConfig 中配置逻辑删除插件：

```java
/** 逻辑删除插件 */
@Bean
public ISqlInjector sqlInjector() {
    return new LogicSqlInjector();
}
```

###### 第三步

在 Controller 中 添加删除方法：

```java
@DeleteMapping("{id}")
public boolean removeById(@PathVariable String id){
    return teacherService.removeById(id);
}
```

<br>

---

<div STYLE="page-break-after: always;">
    <br>
	<br>
	<br>
	<br>
	<br>
</div>

### 8.2	自动填充数据

##### 步骤

###### 第一步

在需要进行自动填充的字段对应的实体类属性上添加 `@TableField` 注解

```java
@ApiModelProperty(value = "创建时间")
@TableField(fill = FieldFill.INSERT)
private Date gmtCreate;

@ApiModelProperty(value = "更新时间")
@TableField(fill = FieldFill.INSERT_UPDATE)
private Date gmtModified;
```

###### 第二步

在 common > service-base 模块下创建 handler 包。

###### 第三步

在 handler 包下实现元对象处理器接口 MyMetaObjectHandler.java

```
package cn.nilnullnaught.servicebase.handler;

import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class MyMetaObjectHandler implements MetaObjectHandler {
    @Override
    public void insertFill(MetaObject metaObject) {
        //属性名称，不是字段名称
        this.setFieldValByName("gmtCreate", new Date(), metaObject);
        this.setFieldValByName("gmtModified", new Date(), metaObject);
    }

    @Override
    public void updateFill(MetaObject metaObject) {
        this.setFieldValByName("gmtModified", new Date(), metaObject);
    }
}
```

<br>

---

<div STYLE="page-break-after: always;">
    <br>
	<br>
	<br>
	<br>
	<br>
</div>

### 8.3	跨域配置

##### 实现跨域

在 Controller 上添加注解 `@CrossOrigin`。

<br>

---

<div STYLE="page-break-after: always;">
    <br>
	<br>
	<br>
	<br>
	<br>
</div>
### 8.4	分页和条件查询

##### 分页实现步骤

###### 第一步

在 MyBatisPlusConfig 中配置分页插件

```
/**
 * 分页插件
 */
@Bean
public PaginationInterceptor paginationInterceptor() {
    return new PaginationInterceptor();
}
```

###### 第二步

在 Controller 中添加分页方法

```java
    @ApiOperation(value = "分页讲师列表")
    @GetMapping("{page}/{limit}")
    public ResponseResult pageList(
            @ApiParam(name = "page", value = "当前页码", required = true)
            @PathVariable Long page,
            @ApiParam(name = "limit", value = "每页记录数", required = true)
            @PathVariable Long limit){

        Page<EduTeacher> pageParam = new Page<>(page, limit);

        eduTeacherService.page(pageParam, null);
        List<EduTeacher> records = pageParam.getRecords();
        long total = pageParam.getTotal();

        return  ResponseResult.ok().data("total", total).data("rows", records);
    }
```

###### 第三步

测试。

<br>

##### 添加查询实现步骤

###### 第一步

创建包 cn.nilnullnaught.serviceedu.entity.vo，在包中创建 EduTeacherQuery.java 查询对象。

```
package cn.nilnullnaught.serviceedu.entity.vo;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

@ApiModel(value = "Teacher查询对象", description = "讲师查询对象封装")
public class EduTeacherQuery {
    private static final long serialVersionUID = 1L;

    @ApiModelProperty(value = "教师名称,模糊查询")
    private String name;

    @ApiModelProperty(value = "头衔 1高级讲师 2首席讲师")
    private Integer level;

    @ApiModelProperty(value = "查询开始时间", example = "2019-01-01 10:10:10")
    private String begin;//注意，这里使用的是String类型，前端传过来的数据无需进行类型转换

    @ApiModelProperty(value = "查询结束时间", example = "2019-12-01 10:10:10")
    private String end;

	//省略 getter 与 setter 
}

```

###### 第二步

在 service 包的 EduTeacherService 接口中添加以下代码：

```java
public interface EduTeacherService extends IService<EduTeacher> {
    void pageQuery(Page<EduTeacher> pageParam, EduTeacherQuery teacherQuery);
}
```

###### 第三步

在 service > impl 包的 EduTeacherServiceImpl 类中进行实现

```java
package cn.nilnullnaught.serviceedu.service.impl;

/**
 * <p>
 * 讲师 服务实现类
 * </p>
 *
 * @author nilnullnaught
 * @since 2021-10-15
 */
@Service
public class EduTeacherServiceImpl extends ServiceImpl<EduTeacherMapper, EduTeacher> implements EduTeacherService {

    @Override
    public void pageQuery(Page<EduTeacher> pageParam, EduTeacherQuery teacherQuery) {

        QueryWrapper<EduTeacher> queryWrapper = new QueryWrapper<>();
        queryWrapper.orderByAsc("sort");

        if (teacherQuery == null){
            baseMapper.selectPage(pageParam, queryWrapper);
            return;
        }

        String name = teacherQuery.getName();
        Integer level = teacherQuery.getLevel();
        String begin = teacherQuery.getBegin();
        String end = teacherQuery.getEnd();

		//导入 org.springframework.util.StringUtils 包
        if (!StringUtils.isEmpty(name)) {
            queryWrapper.like("name", name);
        }

        if (!StringUtils.isEmpty(level) ) {
            queryWrapper.eq("level", level);
        }

        if (!StringUtils.isEmpty(begin)) {
            queryWrapper.ge("gmt_create", begin);
        }

        if (!StringUtils.isEmpty(end)) {
            queryWrapper.le("gmt_create", end);
        }

        baseMapper.selectPage(pageParam, queryWrapper);
    }
}

```

###### 第四步

修改controller 的 pageList 方法，为分页查询添加条件查询：

```
@ApiOperation(value = "分页讲师列表")
    @GetMapping("{page}/{limit}")
    public ResponseResult pageList(

            @ApiParam(name = "page", value = "当前页码", required = true)
            @PathVariable Long page,

            @ApiParam(name = "limit", value = "每页记录数", required = true)
            @PathVariable Long limit,

            @ApiParam(name = "eduTeacherQuery", value = "查询对象", required = false)
                    EduTeacherQuery eduTeacherQuery) {


        //创建分页对象
        Page<EduTeacher> pageParam = new Page<>(page, limit);

        //使用 service 中的条件查询 API
        eduTeacherService.pageQuery(pageParam,eduTeacherQuery);

        List<EduTeacher> records = pageParam.getRecords();
        long total = pageParam.getTotal();

        return ResponseResult.ok().data("total", total).data("rows", records);
    }
```

<br>

---

<div STYLE="page-break-after: always;">
    <br>
	<br>
	<br>
	<br>
	<br>
</div>

### 8.5	新增、修改、简单查询

##### 新增

```java
    @ApiOperation(value = "新增讲师")
    @PostMapping
    public ResponseResult save(
            @ApiParam(name = "teacher", value = "讲师对象", required = true)
            @RequestBody EduTeacher eduTeacher){

        eduTeacherService.save(eduTeacher);
        return ResponseResult.ok();
    }
```

<br>

##### 根据id查询

```java
    @ApiOperation(value = "根据ID查询讲师")
    @GetMapping("{id}")
    public ResponseResult getById(
            @ApiParam(name = "id", value = "讲师ID", required = true)
            @PathVariable String id){

        EduTeacher eduTeacher = eduTeacherService.getById(id);
        return ResponseResult.ok().data("item", eduTeacher);
    }
```

<br>

##### 根据id修改

```java
    @ApiOperation(value = "根据ID修改讲师")
    @PutMapping("{id}")
    public ResponseResult updateById(
            @ApiParam(name = "id", value = "讲师ID", required = true)
            @PathVariable String id,

            @ApiParam(name = "teacher", value = "讲师对象", required = true)
            @RequestBody EduTeacher eduTeacher){

        eduTeacher.setId(id);
        eduTeacherService.updateById(eduTeacher);
        return ResponseResult.ok();
    }
```

<br>

----

<div STYLE="page-break-after: always;">
    <br>
	<br>
	<br>
	<br>
	<br>
</div>
