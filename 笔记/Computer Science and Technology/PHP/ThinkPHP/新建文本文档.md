# x	配置文件

## 3.0	概述

##### ThinkPHP 配置文件

- **ThinkPHP 的配置文件有两种形式**：
  1. **.env 文件**：. env 环境变量用于本地开发测试，部署后会被忽略
  2. **根目录下的 config**：有很多类型的配置，适用于部署;

---

<div STYLE="page-break-after: always;"></div>

## 3.1	开启调试模式

##### 开启调试模式的方法

- **第一种方法**：直接将根目录下的 `.example.env` 文件修改为 `.env` 文件，该文件中默认开启了调试模式。
- 第二种方法：在 `.env` 文件中修改 `APP_DEBUG` 属性为 `true` 。

##### 开启调试模式后的好处

1. 记录系统运行流程的执行过程;
2. 展示错误和调试信息，并开启日志记录;
3. 模版修改可以及时生效(不会被缓存干扰);
4. 启动右下角的Trace调试功能，更加强大;
5. 发生异常时，也会显示异常信息。

##### 📌关闭调试模式时，显示简要的错误提示信息

1. 首先，关闭调试模式 `APP_ DEBUG = false`;
2. 然后，根目录下 `config` 的 `app. php` 最后一项设置为: `show_ error_ msg => true`

---

<div STYLE="page-break-after: always;"></div>

## 3.2	获取配置文件的值

##### 例——获取 .env 文件的值

```php
<?php
namespace app\controller;
use think\facade\Env;

class test
{
    public function index(){
        return Env::get('database.hostname');
    }

    //判断 .env 配置文件是否存在
    public function has(){
        echo Env::has('database.hostname');
    }
}
```

##### 例——获取 config 文件中的值

```php
<?php
namespace app\controller;
use think\facade\Config;

class test
{
    public function index(){
        return Config::get('database.connections.mysql.hostname');
    }
    
    //判断 .env 配置文件是否存在
    public function has(){
        echo Config::has('database.connections.mysql.hostname');
    }
}
```

---

<div STYLE="page-break-after: always;"></div>

# 3	URL 解析

## 3.0	概述

##### PHP 中的 URL

- ThinkPHP 框架中的很多操作都是通过 URL 来实现的。ThinkPHP 6.0 中的 URL 访问受路由影响，如果没有开启强制路由模式，并且没有定义或匹配路由，则使用 **默认的 URL 形式**。

---

<div STYLE="page-break-after: always;"></div>

## 3.1	默认 URL

##### 单应用模式下的默认 URL 的基本格式

```
http://serverName/index.php（或者其它入口文件）/控制器/操作/参数名/值…
```

- **`http://serverName`** ：域名地址。*（例如 `http://localhost:8000` 或 `http://localhost/ThinkPHP/public`）*
- **index.php** ：public 目录下的 index. php 文件。
- **控制器**：app/controller 目录下的 .php 文件。
- **操作**：操作即控制器类里面的方法*（比如 `index()` 或 `hello()`）*。
- **参数与值**：如果操作拥有参数，那么通过 **参数名/具体值** 的形式进行传参

##### 例——访问简单的 URL

```php
<?php
namespace app\controller;

class test
{
    public function index(){
        return request()->controller();//返回当前 Controller 的名称
    }

    public function hello($value = ''){
        echo "Hello ".$value;
        $value."!";
    }
}
```

- 输入地址 `http://localhost:8000/test/hello/value/world`：

![image-20210323182224753](img/image-20210323182224753.png)

- 输入地址 `http://localhost:8000/test`：

![image-20210323182347936](img/image-20210323182347936.png)

##### 自动多应用模式下的默认 URL格式

```
http://serverName/index.php/应用/控制器/操作/参数/值...
```

##### 📌对于不支持 PATHINFO 的服务器可以使用兼容模式的 URL

```
http://serverName/index.php?s=/控制器/操作/[参数名/参数值...]
```

---

<div style="page-break-after: always;"></div>

## 3.2	URL 重写

##### 作用

- 可以通过 URL 重写隐藏应用的入口文件 `index.php`*（虽然也可以是其它的入口文件，但 URL 重写通常只能设置一个入口文件）*。



---

<div style="page-break-after: always;"></div>

##### URL 重写（隐藏应用的入口文件 `index.php`）

- **说明**：可以通过 URL 重写隐藏应用的入口文件 `index.php`（也可以是其它的入口文件，但 URL 重写通常只能设置一个入口文件）。

- **Apache 服务器下的 URL 重写**

  1. `httpd.conf`配置文件中加载了`mod_rewrite.so`模块

  2. `AllowOverride None` 将`None`改为 `All`

  3. 把下面的内容保存为`.htaccess`文件放到应用入口文件的同级目录下

     ```
     <IfModule mod_rewrite.c>
       Options +FollowSymlinks -Multiviews
       RewriteEngine On
     
       RewriteCond %{REQUEST_FILENAME} !-d
       RewriteCond %{REQUEST_FILENAME} !-f
       RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]
     </IfModule>
     ```

- **IIS 服务器下的 URL 重写**：

  - 如果你的服务器环境支持 `ISAPI_Rewrite` 的话，可以配置`httpd.ini`文件，添加下面的内容：

    ```
    RewriteRule (.*)$ /index\.php\?s=$1 [I]
    ```

  - 在IIS的高版本下面可以配置`web.Config`，在中间添加`rewrite`节点：

    ```
    <rewrite>
     <rules>
     <rule name="OrgPage" stopProcessing="true">
     <match url="^(.*)$" />
     <conditions logicalGrouping="MatchAll">
     <add input="{HTTP_HOST}" pattern="^(.*)$" />
     <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" />
     <add input="{REQUEST_FILENAME}" matchType="IsDirectory" negate="true" />
     </conditions>
     <action type="Rewrite" url="index.php/{R:1}" />
     </rule>
     </rules>
     </rewrite>
    ```

- **Nginx 服务器下的 URL 重写**：

  - 在 Nginx 低版本中，是不支持 PATHINFO 的，但是可以通过在 `Nginx.conf` 中配置转发规则实现：

    ```
    location / { // …..省略部分代码
       if (!-e $request_filename) {
       		rewrite  ^(.*)$  /index.php?s=/$1  last;
        }
    }
    ```

    - 其实内部是转发到了 ThinkPHP 提供的兼容 URL，利用这种方式，可以解决其他不支持 PATHINFO 的 WEB 服务器环境。

<br>

---

<div STYLE="page-break-after: always;"></div>

## 