# 1	ThinkPHP

## 1.1	概述

##### 什么是 ThinkPHP

- ThinkPHP是一个免开源的、快速简单的、面向对象的 **轻量级PHP开发框架**，是为了敏捷 WEB 应用开发和简化企业应用开发而生。ThinkPHP从诞生以来一直秉承简洁实用的设计原则，在保持出色的性能和至简代码的同时，更注重易用性。

##### ThinkPHP 的开源协议

- ThinkPHP 遵循 `Apache2` 开源许可协议发布，意味着你可以免费使用 ThinkPHP，甚至允许把你基于 ThinkPHP 开发的应用开源或商业产品发布/销售。

##### ThinkPHP 6.0 主要新特性

- 采用 PHP7 强类型（严格模式）
- 支持更多的 PSR 规范
- 多应用支持
- `ORM` 组件独立
- 改进的中间件机制
- 更强大和易用的查询
- 全新的事件系统
- 支持容器 `invoke` 回调
- 模板引擎组件独立
- 内部功能中间件化
- SESSION 机制改进
- 缓存及日志支持多通道
- 引入 `Filesystem` 组件
- 对 `Swoole` 以及协程支持改进
- 对 IDE 更加友好。
- 统一和精简大量用法。

---

<br>

## 1.2	Hello World

### 1.2.1	Windows 环境下安装 ThinkPHP6.0

##### 步骤

1. 下载并安装 Composer[^Composer]。

2. 如果是第一次安装，切换到 WEB 根目录下面并执行下面的命令：

   ```shell
   #安装稳定版 ThinkPHP
   composer create-project topthink/think tp
   ```

3. 开启调试模式。由于应用默认是部署模式，在开发阶段，可以修改环境变量 `APP_DEBUG` 开启调试模式，上线部署后切换到部署模式。

##### 测试运行

1. 

##### .env 文件

- **什么是 .env 文件**：环境变量文件。本地开发时可以在应用根目录下面定义 `.env` 文件。
- **.example.env 文件**：通 过Composrer  的 `create-project` 命令安装后 Think PHP 后，在根目录会自带一个`.example.env`文件（环境变量示例），你可以直接更名为`.env`文件并根据你的要求进行修改。*（该示例文件已经开启调试模式）*

---

<br>

### 1.2.2	测试运行

##### 步骤

1. 进入命令行下面，执行下面指令

   ```shell
   php think run
   ```

2. 在浏览器中输入地址：

   ```php
   http://localhost:8000/
   ```

3. 进入欢迎页面。

---

<br>

## 1.3	ThinkPHP 编程规范

##### 目录和文件

- 目录使用小写 + 下划线；
- 类库、函数文件统一以 `.php` 为后缀；
- 类的文件名均以命名空间定义，并且命名空间的路径和类库文件所在路径一致；
- 类（包含接口和 Trait）文件采用驼峰法命名（首字母大写），其它文件采用小写 + 下划线命名；
- 类名（包括接口和 Trait）和文件名保持一致，统一采用驼峰法命名（首字母大写）；

##### 函数和类、属性命名

- 类的命名采用驼峰法（首字母大写），例如 `User`、`UserType`；
- 函数的命名使用小写字母和下划线（小写字母开头）的方式，例如 `get_client_ip`；
- 方法的命名使用驼峰法（首字母小写），例如 `getUserName`；
- 属性的命名使用驼峰法（首字母小写），例如 `tableName`、`instance`；
- 特例：以双下划线`__`打头的函数或方法作为魔术方法，例如 `__call` 和 `__autoload`；

##### 常量和配置

- 常量以大写字母和下划线命名，例如 `APP_PATH`；
- 配置参数以小写字母和下划线命名，例如 `url_route_on` 和`url_convert`；
- 环境变量定义使用大写字母和下划线命名，例如`APP_DEBUG`；

##### 数据表和字段

- 数据表和字段采用小写加下划线方式命名，并注意字段名不要以下划线开头，例如 `think_user` 表和 `user_name`字段，不建议使用驼峰和中文作为数据表及字段命名。

---

<br>

## 1.4	目录结构

### 1.4.0	ThinkPHP 目录结构

##### 📌ThinkPHP 6.0 多应用部署

- ThinkPHP 6.0 支持多应用模式部署，实际的目录结构取决于采用的是单应用还是多应用模式。

##### 📌ThinkPHP 部署注意事项

1. 在实际的部署中，请确保只有public目录可以对外访问。
2. 在 mac 或者 linux 环境下面，注意需要设置 runtime 目录权限为777。

---

<br>

### 1.4.1	单应用模式

##### 说明

- 默认安装后的目录结构就是一个单应用模式。

##### 应用结构

```
www  WEB部署目录（或者子目录）
├─app           应用目录
│  ├─controller      控制器目录
│  ├─model           模型目录
│  ├─ ...            更多类库目录
│  │
│  ├─common.php         公共函数文件
│  └─event.php          事件定义文件
│
├─config                配置目录
│  ├─app.php            应用配置
│  ├─cache.php          缓存配置
│  ├─console.php        控制台配置
│  ├─cookie.php         Cookie配置
│  ├─database.php       数据库配置
│  ├─filesystem.php     文件磁盘配置
│  ├─lang.php           多语言配置
│  ├─log.php            日志配置
│  ├─middleware.php     中间件配置
│  ├─route.php          URL和路由配置
│  ├─session.php        Session配置
│  ├─trace.php          Trace配置
│  └─view.php           视图配置
│
├─view            视图目录
├─route                 路由定义目录
│  ├─route.php          路由定义文件
│  └─ ...   
│
├─public                WEB目录（对外访问目录）
│  ├─index.php          入口文件
│  ├─router.php         快速测试文件
│  └─.htaccess          用于apache的重写
│
├─extend                扩展类库目录
├─runtime               应用的运行时目录（可写，可定制）
├─vendor                Composer类库目录
├─.example.env          环境变量示例文件
├─composer.json         composer 定义文件
├─LICENSE.txt           授权说明文件
├─README.md             README 文件
├─think                 命令行入口文件
```

---

<br>

### 1.4.2	多应用模式

##### 说明

- 如果你需要一个多应用的项目架构，目录结构可以参考下面的结构进行调整（关于配置文件的详细结构参考后面章节）。

##### 项目结构

```
www  WEB部署目录（或者子目录）
├─app           应用目录
│  ├─app_name           应用目录
│  │  ├─common.php      函数文件
│  │  ├─controller      控制器目录
│  │  ├─model           模型目录
│  │  ├─view            视图目录
│  │  ├─config          配置目录
│  │  ├─route           路由目录
│  │  └─ ...            更多类库目录
│  │
│  ├─common.php         公共函数文件
│  └─event.php          事件定义文件
│
├─config                全局配置目录
│  ├─app.php            应用配置
│  ├─cache.php          缓存配置
│  ├─console.php        控制台配置
│  ├─cookie.php         Cookie配置
│  ├─database.php       数据库配置
│  ├─filesystem.php     文件磁盘配置
│  ├─lang.php           多语言配置
│  ├─log.php            日志配置
│  ├─middleware.php     中间件配置
│  ├─route.php          URL和路由配置
│  ├─session.php        Session配置
│  ├─trace.php          Trace配置
│  └─view.php           视图配置
│
├─public                WEB目录（对外访问目录）
│  ├─index.php          入口文件
│  ├─router.php         快速测试文件
│  └─.htaccess          用于apache的重写
│
├─extend                扩展类库目录
├─runtime               应用的运行时目录（可写，可定制）
├─vendor                Composer类库目录
├─.example.env          环境变量示例文件
├─composer.json         composer 定义文件
├─LICENSE.txt           授权说明文件
├─README.md             README 文件
├─think                 命令行入口文件
```

##### 📌多应用部署的注意点

- 多应用模式部署后，需要删除 app 目录下的 controller 目录*（系统根据该目录作为判断是否单应用的依据）*。

---

<br>

### 1.4.3	默认应用文件

##### 说明

- 默认安装后，`app`目录下会包含以下文件：

  ```
  ├─app           应用目录
  │  │
  │  ├─BaseController.php    默认基础控制器类
  │  ├─ExceptionHandle.php   应用异常定义文件
  │  ├─common.php            全局公共函数文件
  │  ├─middleware.php        全局中间件定义文件
  │  ├─provider.php          服务提供定义文件
  │  ├─Request.php           应用请求对象
  │  └─event.php             全局事件定义文件
  ```

##### 📌默认配置文件使用注意点

- `BaseController.php`、`Request.php` 和`ExceptionHandle.php`三个文件是系统默认提供的基础文件，位置你可以随意移动，但注意要同步调整类的命名空间。
- 如果不需要使用`Request.php` 和`ExceptionHandle.php`文件，或者要调整类名，必须同步调整`provider.php`文件中的容器对象绑定。

##### 📌provider.php

- `provider.php`服务提供定义文件只能全局定义，不支持在应用下单独定义。

---

<br>

# 2	框架架构

## 2.1	请求流程

##### 说明

- 对于一个HTTP应用来说，从用户发起请求到响应输出结束，大致的标准请求流程如下：
  1. 载入 `Composer` 的自动加载 `autoload` 文件
  2. 实例化系统应用基础类 `think\App`
  3. 获取应用目录等相关路径信息
  4. 加载全局的服务提供 `provider.php` 文件
  5. 设置容器实例及应用对象实例，确保当前容器对象唯一
  6. 从容器中获取 `HTTP` 应用类 `think\Http`
  7. 执行 `HTTP` 应用类的 `run` 方法启动一个 `HTTP` 应用
  8. 获取当前请求对象实例（默认为 `app\Request` 继承 `think\Request`）保存到容器
  9. 执行 `think\App` 类的初始化方法 `initialize`
  10. 加载环境变量文件 `.env` 和全局初始化文件
  11. 加载全局公共文件、系统助手函数、全局配置文件、全局事件定义和全局服务定义
  12. 判断应用模式（调试或者部署模式）
  13. 监听 `AppInit` 事件
  14. 注册异常处理
  15. 服务注册
  16. 启动注册的服务
  17. 加载全局中间件定义
  18. 监听 `HttpRun` 事件
  19. 执行全局中间件
  20. 执行路由调度（`Route`类`dispatch`方法）
  21. 如果开启路由则检查路由缓存
  22. 加载路由定义
  23. 监听`RouteLoaded`事件
  24. 如果开启注解路由则检测注解路由
  25. 路由检测（中间流程很复杂 略）
  26. 路由调度对象`think\route\Dispatch`初始化
  27. 设置当前请求的控制器和操作名
  28. 注册路由中间件
  29. 绑定数据模型
  30. 设置路由额外参数
  31. 执行数据自动验证
  32. 执行路由调度子类的`exec`方法返回响应`think\Response`对象
  33. 获取当前请求的控制器对象实例
  34. 利用反射机制注册控制器中间件
  35. 执行控制器方法以及前后置中间件
  36. 执行当前响应对象的`send`方法输出
  37. 执行HTTP应用对象的`end`方法善后
  38. 监听`HttpEnd`事件
  39. 执行中间件的`end`回调
  40. 写入当前请求的日志信息

---

<br>

## 2.2	架构总览

##### 入口文件

- 用户请求的 PHP 文件，负责处理请求*（注意，不一定是 HTTP 请求）*的生命周期，入口文件位于 `public` 目录下面。最常见的入口文件是 `index.php`。
- **多应用多入口**：`6.0` 支持多应用多入口，你可以给每个应用增加入口文件，例如给后台应用单独设置的一个入口文件 `admin.php`。但是，如果开启自动多应用的话，一般只需要一个入口文件`index.php`。

##### 多应用

- `6.0` 版本提供了对多应用的良好支持，每个应用是一个 `app` 目录的子目录（或者指定的 `composer` 库），每个应用具有独立的路由、配置，以及 MVC 相关文件，这些应用可以公用框架核心以及扩展。而且可以支持 `composer` 应用加载。

##### 容器

- ThinkPHP 使用**（对象）容器** 统一管理对象实例及依赖注入。
- 容器类的工作由 `think\Container` 类完成，但大多数情况下我们都是通过应用类（`think\App`类）或是`app`助手函数来完成容器操作，容器中所有的对象实例都可以通过容器标识单例调用，你可以给容器中的对象实例绑定一个对象标识，如果没有绑定则使用类名作为容器标识。

## 系统服务

系统服务的概念是指在执行框架的某些组件或者功能的时候需要依赖的一些基础服务，服务类通常可以继承系统的`think\Service`类，但并不强制。

你可以在系统服务中注册一个对象到容器，或者对某些对象进行相关的依赖注入。由于系统服务的执行优先级问题，可以确保相关组件在执行的时候已经完成相关依赖注入。

## 路由

路由是用于规划（一般同时也会进行简化）请求的访问地址，在访问地址和实际操作方法之间建立一个路由规则 => 路由地址的映射关系。

ThinkPHP并非强制使用路由，如果没有定义路由，则可以直接使用“控制器/操作”的方式访问，如果定义了路由，则该路由对应的路由地址就被不能直接访问了。一旦开启强制路由参数，则必须为每个请求定义路由（包括首页）。

使用路由有一定的性能损失，但随之也更加安全，因为每个路由都有自己的生效条件，如果不满足条件的请求是被过滤的。你远比你在控制器的操作中进行各种判断要实用的多。

其实路由的作用远非URL规范这么简单，还可以实现验证、权限、参数绑定及响应设置等功能。

## 控制器

每个应用下面拥有独立的类库及配置文件，一个应用下面有多个控制器负责响应请求，而每个控制器其实就是一个独立的控制器类。

控制器主要负责请求的接收，并调用相关的模型处理，并最终通过视图输出。严格来说，控制器不应该过多的介入业务逻辑处理。

> 事实上，控制器是可以被跳过的，通过路由我们可以直接把请求调度到某个模型或者其他的类进行处理。

`ThinkPHP`的控制器类比较灵活，可以无需继承任何基础类库。

一个典型的`Index`控制器类（单应用模式）如下：

```
<?php
namespace app\controller;

class Index 
{
    public function index()
    {
        return 'hello,thinkphp!';
    }
}
```

> 一般建议继承一个基础的控制器，方便扩展。系统默认提供了一个`app\BaseController`控制器类。

## 操作

一个控制器包含多个操作（方法），操作方法是一个URL访问的最小单元。

下面是一个典型的`Index`控制器的操作方法定义，包含了两个操作方法：

```
<?php
namespace app\controller;

class Index 
{
    public function index()
    {
        return 'index';
    }
    
    public function hello(string $name)
    {
        return 'Hello,'.$name;
    }
}
```

操作方法可以不使用任何参数，如果定义了一个非可选参数，并且不是对象类型，则该参数必须通过用户请求传入，如果是URL请求，则通常是通过当前的请求传入，操作方法的参数支持依赖注入。

## 模型

模型类通常完成实际的业务逻辑和数据封装，并返回和格式无关的数据。

> 模型类并不一定要访问数据库，而且在ThinkPHP的架构设计中，只有进行实际的数据库查询操作的时候，才会进行数据库的连接，是真正的惰性连接。

ThinkPHP的模型层支持多层设计，你可以对模型层进行更细化的设计和分工，例如把模型层分为逻辑层/服务层/事件层等等。

模型类通常需要继承`think\Model`类，一个典型的`User`模型器类如下：

```
<?php
namespace app\model;

use think\Model;

class User extends Model
{
}
```

## 视图

控制器调用模型类后，返回的数据通过视图组装成不同格式的输出。视图根据不同的需求，来决定调用模板引擎进行内容解析后输出还是直接输出。

视图通常会有一系列的模板文件对应不同的控制器和操作方法，并且支持动态设置模板目录。

## 模板引擎

模板文件中可以使用一些特殊的模板标签，这些标签的解析通常由模板引擎负责实现。

新版不再内置`think-template`模板引擎，如果需要使用ThinkPHP官方模板引擎，需要单独安装`think-view`模板引擎驱动扩展。

## 驱动

系统很多的组件都采用驱动式设计，从而可以更灵活的扩展，驱动类的位置默认是放入核心类库目录下面，也可以重新定义驱动类库的命名空间而改变驱动的文件位置。

> `6.0`版本的驱动采用`Composer`的方式安装和管理。

## 中间件

中间件主要用于拦截或过滤应用的`HTTP`请求，并进行必要的业务处理。

> 新版部分核心功能使用中间件处理，你可以灵活关闭。包括Session功能、请求缓存和多语言功能。

## 事件

`6.0`已经使用事件机制替代原来的行为和Hook机制，可以在应用中使用事件机制的特性来扩展功能。

此外数据库操作和模型操作在完成数据操作的回调机制，也使用了事件机制。

## 助手函数

系统为一些常用的操作提供了助手函数支持。使用助手函数和性能并无直接影响，只是某些时候无法享受IDE自动提醒的便利，但是否使用助手函数看项目自身规范，在应用的公共函数文件中也可以对系统提供的助手函数进行重写。

---

<br>

# 附录

##### 最后编辑时间

- 2021/03/18

##### 环境

- 

##### 参考

- 

##### 相关资料

- 

##### 脚注

[^Composer]: Composer 是 PHP 的一个依赖管理工具。它允许你申明项目所依赖的代码库，它会在你的项目中为你安装他们。

[^.env 文件]: 

##### 代码链接

[1]:

##### 锚点

[](#1) 

##### 质疑

[^!1]: 

##### 疑问

[^?1]: 
