# 1	PHP

## 1.1	PHP 概述

##### 什么是 PHP

- PHP*（Hypertext Preprocessor，即超文本预处理器）*是一种通用开源脚本语言[^脚本语言]。

##### PHP 适合做什么

- PHP 主要适用于 Web 开发领域。

##### PHP 的优点

- 

##### PHP 的缺点

- 

---

<br>

## 1.2	PHP 基本概念

##### PHP 脚本

- PHP 脚本以 `<?php` 开始，以 `?>` 结束，可以放在文档中的任何位置。
- PHP 脚本在服务器上执行，然后将纯 HTML 结果发送回浏览器。

##### php 文件

- PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码。PHP 文件的默认文件扩展名是 `.php`。

---

<br>

## 1.3	PHP Hello World

**例**

```php+HTML
<!DOCTYPE html>
<html>
<body>

<h1>My first PHP page</h1>

<?php
echo "Hello World!";
?>

</body>
</html>
```

- 在 Web 服务器的 web 目录中创建 .php 文件即可，服务器将自动解析 php 文件。

---

<br>

# 2	基本语法

## 2.1	PHP 标记

##### 说明

- 当解析一个文件时，PHP 会寻找起始和结束标记，也就是 `<?php` 和 `?>`，这告诉 PHP 开始和停止解析二者之间的代码。
- **该解析方式使得 PHP 可以被嵌入到各种不同的文档中**，而任何起始和结束标记之外的部分都会被 PHP 解析器忽略。

##### PHP 短标记

- 短标记以 `<?` 开始以 `?>` 结束，可以像正常标记一样使用。
- 短标记被默认开启的，但是也可以通过修改配置文件 `short_open_tag php.ini` 禁用。或者在 PHP 安装时使用 --disable-short-tags 配置，将该功能默认禁用。
- 因为短标记可以被禁用，所以建议使用普通标记 (`<?php ?>` 和 `<?= ?>`) 来最大化兼容性。

##### 📌在纯 PHP 代码的文件中不要使用结束标记

- 如果文件内容仅仅包含 PHP 代码，最好在文件末尾删除 PHP 结束标记。这可以避免在 PHP 结束标记之后万一意外加入了空格或者换行符，会导致 PHP 开始输出这些空白。

##### 📌<?php echo 的简写

- `<?php echo` 可以简写为 `<?=`。
- **关闭短标记不会影响到缩写形式 `<?=` **，它总是可用的。

---

<br>

## 2.2	从 HTML 中分离

##### **说明**

- 凡是在一对开始和结束标记之外的内容都会被 PHP 解析器忽略，这使得 PHP 文件可以具备混合内容。 可以使 PHP 嵌入到 HTML 文档中去。
- 但是，**处于条件语句中间时**，此时 PHP 解释器会根据条件判断来决定哪些输出，哪些跳过。

##### 例：使用条件的高级分离

```php+HTML
<?php if ($expression == true): ?>
  This will show if the expression is true.
<?php else: ?>
  Otherwise this will show.
<?php endif; ?>
```

- 上例中 PHP 将跳过条件语句未达成的段落，即使该段落位于 PHP 开始和结束标记之外。

##### 📌更有效率的输出

- 要输出大段文本时，跳出 PHP 解析模式通常比将文本通过 echo 或 print 输出更有效率。

---

<br>

## 2.3	指令分隔符

##### 说明

- PHP 需要在每个语句后用分号结束指令。
- PHP 代码中的结束标记隐含表示了一个分号，因此在一个 PHP 代码段中的最后一行可以不用分号结束。

##### 📌省略文件末尾的结束标记

- 文件末尾的 PHP 代码段结束标记可以省略，有些情况下*（比如使用 include 或者 require 时）*省略掉会更好些。

---

<br>

# 3	数据类型

## 3.0	PHP 数据类型概述

##### PHP 支持 10 种原始数据类型

- **四种标量类型**：
  - bool*（布尔型）*
  - int*（整型）*
  - float*（浮点型，也称作 double*)
  - string*（字符串）*
- **四种复合类型**：
  - array*（数组）*
  - object*（对象）*
  - callable*（可调用）*
  - iterable*（可迭代）*
- **两种特殊类型**：
  - resource*（资源）*
  - NULL*（无类型）*

##### 变量的数据类型

- 变量的类型通常不是由程序员设定的，确切地说，是由 PHP 根据该变量使用的上下文在运行时决定的。
- 变量根据其当时的类型在特定场合下会表现出不同的值。

##### 📌var_dump() 函数

- 如果想查看某个表达式的值和类型，用 `var_dump()` 函数。

##### 📌gettype() 函数

- 如果只是想得到一个易读懂的类型的表达方式用于调试，用 `gettype()` 函数。

##### 📌is_type 函数

- 要检验某个类型，使用 `is_type` 函数

---

<br>

## 3.1	Boolean 布尔类型

忽略

---

<br>

## 3.2	Integer 整型

##### 📌包含下划线的整型

- 从 PHP 7.4.0 开始，整型数值可能会包含下划线 `_`，为了更好的阅读体验，这些下划线在展示的时候，会被 PHP 过滤掉。

---

<br>

## 3.3	Float 浮点类型



---

<br>

## 3.4	String 字符串

##### 说明

- 一个字符串 string 就是由一系列的字符组成，其中每个字符等同于一个字节。这意味着 PHP 只能支持 256 的字符集，因此**不支持 Unicode** 。

##### PHP 字符串的 4 种方式表达形式

- 单引号
- 双引号
- heredoc 语法结构
- nowdoc 语法结构*（自 PHP 5.3.0 起）*

##### 单引号

- 定义一个字符串的最简单的方法是用单引号 `'` 把它包围起来。
- 注意: 不像双引号和 heredoc 语法结构，在单引号字符串中的变量和特殊字符的转义序列将不会被替换。

##### 双引号

- 如果字符串是包围在双引号 `"` 中， PHP 将对一些特殊的字符进行解析

##### Heredoc 结构

- Heredoc 结构就象是没有使用双引号的双引号字符串。

- 在 `<<<` 运算符之后提供一个标识符，然后换行。接下来是字符串 string 本身，最后要用前面定义的标识符作为结束标志。

- 结束时所引用的标识符必须在该行的第一列，而且，标识符的命名也要像其它标签一样遵守 PHP 的规则：只能包含字母、数字和下划线，并且必须以字母和下划线作为开头。

- **例**：

  ```php
  <?php
  $str = <<<EOD
  Example of string
  spanning multiple lines
  using heredoc syntax.
  EOD;
  ```

- 📌**注意**：

  - 在 `heredoc` 结构中单引号不用被转义，但是上文中列出的转义序列还可以使用。变量将被替换，但在 `heredoc` 结构中含有复杂的变量时要格外小心。
  - 结束标识符这行除了可能有一个分号 `;` 外，绝对不能包含其它字符。这意味着标识符不能缩进，分号的前后也不能有任何空白或制表符。更重要的是结束标识符的前面必须是个被本地操作系统认可的换行，比如在 UNIX 和 Mac OS X 系统中是 `\n`，而结束定界符之后也必须紧跟一个换行。
  - 在 PHP 5.3.0 以后，才可以用 `Heredoc` 结构来初始化静态变量和类的属性和常量。

##### Nowdoc 结构

- 就象 `heredoc` 结构类似于双引号字符串，`Nowdoc` 结构是类似于单引号字符串的。
- Nowdoc 结构很像 heredoc 结构，但是 **nowdoc 中不进行解析操作**。这种结构很适合用于嵌入 PHP 代码或其它大段文本而无需对其中的特殊字符进行转义。

##### 📌拼接字符串

- 字符串可以用 `.`*（点）*运算符连接起来，注意 `+`*（加号）*运算符没有这个功能。

---

<br>

## 3.5	数组

##### 说明

- **PHP 中的数组实际上是一个有序映射**。映射是一种把 values 关联到 keys 的类型。此类型在很多方面做了优化，因此可以把它当成真正的数组。  

##### 定义数组

- 可以用 `array()` 来新建一个数组。它接受任意数量用逗号分隔的键值对：

  ```php
  array(  key1 =>  value1,key2 =>  value2, ... ,key_n =>  value_n
  ```

  - 键*（key）*可以是一个整数或字符串。
  - 值*（value）*可以是任意类型的值。

- 📌**注意**：

  - 定义数组时，最后一个数组单元之后的逗号可以省略。但是，**对于多维数组，最好保留最后一个逗号**，这样要添加一个新单元时更方便。
  - 自 5.4 起可以使用短数组定义语法，用 `[]` 替代 `array()`。
  - PHP 数组可以同时含有 integer 和 string 类型的键名，因为 PHP 实际并不区分索引数组和关联数组。

- **例**：

  ```php
  <?php
  $array = array(
      "foo" => "bar",
      "bar" => "foo",
  );
  
  // 自 PHP 5.4 起
  $array = [
      "foo" => "bar",
      "bar" => "foo",
  ];
  ?>
  ```

##### 📌key 的强制类型转换

- 包含有合法整型值的字符串会被转换为整型。*（例如键名 "8" 实际会被储存为 8。但是 "08" 则不会强制转换，因为其不是一个合法的十进制数值）*
- 浮点数也会被转换为整型，并且其小数部分会被舍去。*（例如键名 8.7 实际会被储存为 8）*
- 布尔值也会被转换成整型。即键名 `true` 实际会被储存为 1 而键名 `false` 会被储存为 0。
- Null 会被转换为空字符串，即键名 `null` 实际会被储存为 ""。
- 数组和对象不能被用为键名。坚持这么做会导致警告。

##### 访问和修改数组

- 方括号和花括号都可以用来访问数组单元。

- 通过在方括号内指定键名，可以获取对应的值，并进行修改。

- 可以通过下列形式在数组的最后添加一个新的元素：

  ```php
  <?php
      $array = array()
      $array[] = "new"
  ```

  - 如果给出方括号但没有指定键名，则取当前最大整数索引值，新的键名将是该值加上 1。如果当前还没有整数索引，则键名将为 `0`。

- 📌**注意**：

  - 使用如果数组之前不存在，使用 `$array[key] = value`  的形式会创建一个新的数组。但是，**不推荐这样创建数组**，因为该形式与字符串访问运算符一致，如果存在与 array 同名的字符串，`[]` 会作为 **字符串访问运算符** 使用。
  - 对于字符串形式的键名，访问时必须使用引号。

##### 数组删除

- 通过 `unset()` 函数可以删除数组或数组中指定的键值对，例：

  ```php
  <?php
  $arr = array("Ⅰ" => "one","Ⅱ"=>"two",'Ⅲ'=>'three');
                  
  unset($arr["Ⅰ"]); // This removes the element from the array
  
  unset($arr);    // This deletes the whole array
  ?>
  ```

- 📌**注意**：

  - 数组中的元素被删除后，其最大整数索引的信息会被保留，所以如果使用  `arr[]` 的形式向数组中添加新的值，那么新的值的索引将会是原先存在过的最大整数索引 +1。
  - 删除数组中的元素后，可以使用 `array_values()` 函数重建数字索引。

##### 数组合并

- 可以使用 + 将两个数组合并，例

  ```php
  <?php
  
  $array1 = array('1'=>'one','2'=>'two','3'=>'three');
  $array2 = array('4'=>'four','5'=>'five','6'=>'six');
  
  $arr =  $array1 + $array2;
  
  print_r($arr);
  ```

- 📌**注意**：

  - 如果两个数组相同的键，那么在 + 号前面的数组的相同键的值将保留。

---

<br>

## 3.6	Iterable 可迭代对象

##### 说明

- `Iterable` 是 PHP 7.1 中引入的一个伪类型。它接受任何 `array` 或实现了 `Traversable` 接口的对象。这些类型都能用 `foreach` 迭代， 也可以和生成器里的 yield from 一起使用。

##### 可迭代对象作为函数参数

- 可迭代对象可以作为函数参数类型使用，表示函数需要一组值。*（此时通常和  foreach 一起使用）*

- **例**：

  ```php
  <?php
  
  function foo(iterable $iterable) {
      foreach ($iterable as $value) {
          // ...
      } 
  }
  
  ?>
  ```

##### 可迭代对象作为返回值类型

- 可迭代对象还可以用作返回值类型，表示函数将返回一个可迭代的值。 

---

<br>

## 3.7	Object 对象

##### 转换为对象

- 如果将一个对象转换成对象，它将不会有任何变化[^?1]。
- 如果其它任何类型的值被转换成对象，将会创建一个内置类 `stdClass` 的实例。
- 如果该值为 `null`，则新的实例为空。 
- `array` 转换成 `object` 将使键名成为属性名并具有相对应的值。

---

<br>

## 3.8	Resource 资源类型

##### 说明

- 资源是一种特殊变量，用于保存到外部资源的一个引用。
- 资源通过专门的函数来建立和使用。

##### 释放资源

- 引用计数系统是 Zend 引擎的一部分，可以自动检测到一个资源不再被引用了（和 Java 一样）。这种情况下此资源使用的所有外部资源都会被垃圾回收系统释放。因此，很少需要手工释放内存。
- 📌**注意**: 
  - 持久数据库连接比较特殊，它们不会被垃圾回收系统销毁。

---

<br>

## 3.9	NULL

##### 说明

- **`null`** 值表示一个变量没有值。`NULL` 类型唯一可能的值就是 **`null`**。

##### 在下列情况下一个变量被认为是 null

- 被赋值为 **`null`**。
- 尚未被赋值。
- 被 unset。

##### 📌isset()

- `isset()` 可以用于检测变量是否已设置并且非 NULL。

---

<br>

## 3.10	Callback / Callable 类型（未完成）



---

<br>

## 3.11	类型声明（未完成）



---

<br>

## 3.12	类型转换（未完成）



---

<br>

# 4	变量与常量

## 4.1	变量基础

##### PHP 中的变量

- PHP 中的变量使用一个美元符号 `$` 后面跟变量名来表示，变量名区分大小写。

##### 变量名命名规则

- 变量名遵循与 PHP 中其它的标签相同的命名规则。一个有效的变量名由字母或者下划线 `_` 开头，后面跟上任意数量的字母，数字，或者下划线。
- 📌**注意**：
  - 变量名中的字母指是 a-z，A-Z，以及从 128 位到 255 位（0x80-0xff）的 ASCII 字符。

##### 变量的引用赋值

- 引用赋值即新的变量简单的引用了原始变量。改动新的变量将影响到原始变量，反之亦然。

- **语法**：

  - 将一个 & 符号加到将要赋值的变量前。

  - **例**：

    ```php
    <?php
    $foo = 'Bob';              // 将 'Bob' 赋给 $foo
    $bar = &$foo;              // 通过 $bar 引用 $foo
    $bar = "My name is $bar";  // 修改 $bar 变量
    echo $bar;
    echo $foo;                 // $foo 的值也被修改
    ?>
    ```

##### 📌对变量进行初始化

- 虽然在 PHP 中并不需要初始化变量，但对变量进行初始化是个好习惯。未初始化的变量具有其类型的默认值，这在某些情况下会有问题*（例如把一个文件包含到另一个之中时碰上相同的变量名。 使用未初始化的变量会发出 E_NOTICE 错误，不过在向一个未初始化的数组附加单元时不会。）*
- `isset()` 可以用来检测一个变量是否已被初始化。

---

<br>

## 4.2	变量范围（变量作用域）

##### 什么是变量范围

- 变量范围又称变量作用域，即变量定义的上下文背景（也就是它的生效范围）。

- 大部分的 PHP 变量只有一个单独的范围。这个范围的跨度包含了 include 和 require 引入的文件。例如：

  ```php
  <?php
  $a = 1;
  include 'b.inc';
  ?>
  ```

  - 这里变量 `$a` 将会在包含文件 b.inc 中生效。

##### 全局变量

- PHP 中全局变量在函数中使用时必须声明为 global。

- **例**：

  ```php
  <?php
  $a = 1;
  $b = 2;
  
  function Sum(){
      global $a, $b;
      $b = $a + $b;
  }
  
  Sum();
  
  echo $b;
  ?>
  ```

##### 📌在全局范围内访问变量的第二个办法

- 使用 PHP 预定义的  `$GLOBALS` 数组也可以访问全局变量。

- `$GLOBALS` 是一个关联数组，每一个变量为一个元素，键名对应变量名，值对应变量的内容。

- **例**：

  ```php
  <?php
  $a = 1;
  $b = 2;
  
  function Sum(){
      $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
  }
  
  Sum();
  echo $b;
  
  ?>
  ```

##### 静态变量

- 静态变量仅在函数作用域中定义，但当程序执行离开此作用域时，其值并不丢失。

- **例**：

  ```php
  <?php
      function test(){
      static $a = 0;
      echo $a;
      $a++;}
  ?>
  ```

  - 变量 `$a` 仅在第一次调用 `test()` 函数时被初始化，之后每次调用 `test()` 函数都会输出 ​`$a` 的值并加一。

- **静态变量处理递归函数**：

  - 递归函数是一种调用自己的函数。因为可能会无穷递归下去，所以递归函数必须确保有充分的方法来中止递归。**可以使用静态变量作为终止递归函数的判断依据**。

##### 📌PHP 全局和静态变量的实现原理与导致的问题

- PHP 变量的 `static` 和 `global` 定义是以 **引用** 的方式实现的。在函数域内部用 `global` 语句导入的全局变量实际上是建立了一个到全局变量的引用。

- 因此，这可能会导致意外出现，例如：

  ```php
  <?php
  function test_global_ref() {
      global $obj;
      $new = new stdclass;
      $obj = &$new;
  }
  
  function test_global_noref() {
      global $obj;
      $new = new stdclass;
      $obj = $new;
  }
  
  test_global_ref();
  var_dump($obj);
  
  test_global_noref();
  var_dump($obj);
  ?>
  ```

  - 上例会输出：

    ```php
    NULL object(stdClass)#1 (0) { }
    ```

- 类似的问题也适用于 `static` 语句，当在函数中把一个引用赋值给一个静态变量时，第二次调用这个函数时静态变量的值并没有被记住。

---

<br>

## 4.3	可变变量

##### 说明

- 可变变量获取一个普通变量的值作为这个可变变量的变量名。可变变量的变量名可以动态的设置和使用

##### 语法

1. 定义一个普通变量：

   ```php
   <?php
   $a = 'hello';
   ?>
   ```

2. 定义可变变量：

   ```php
   <?php
   $$a = 'world';
   ?>
   ```

3. 这时，两个变量都被定义了，并且`$a` 的内容是 “hello” 并且 `$hello` 的内容是 “world”：

   ```
   <?php
   echo "$a ${$a}";
   
   echo "$a $hello";
   ?>
   ```

   - `$a ${$a}` 和 `$a $hello` 的结果相同，都是 hello world。

---

<br>

## 4.4	来自 PHP 之外的变量

### 4.4.1	HTML 表单

##### 说明

- 当一个表单提交给 PHP 脚本时，表单中的信息会自动在脚本中可用。

##### 访问 HTML 表单中的 POST 数据

```php+HTML
<form action="foo.php" method="POST">
    Name:  <input type="text" name="username"><br />
    Email: <input type="text" name="email"><br />
    <input type="submit" name="submit" value="Submit me!" />
</form>

<?php
echo $_POST['username'];
echo $_REQUEST['username'];
?>
```

##### 访问 GET 数据

- 访问 GET 数据与 访问 POST 数据类似，不过要用适当的 GET 预定义变量。
- GET 也适用于 QUERY_STRING（URL 中在“?”之后的信息）。（例如 http://www.example.com/test.php?id=3 包含有可用 `$_GET['id']` 来访问的 GET 数据）

##### PHP 自动识别

- 变量名中的点和空格被转换成下划线。*（例如 `<input name="a.b" />`  会被替换成 `$_REQUEST["a_b"]`。）*
- PHP 也会识别表单变量上下文中的数组。因此可以将相关的变量编成组，或者利用此特性从多选输入框中取得值。

---

<br>

### 4.4.2	IMAGE SUBMIT

##### 说明

- 当提交表单时，可以用一幅图像代替标准的提交按钮，例如：

  ```
  <input type="image" src="image.gif" name="sub" />
  ```

  - 当用户点击到图像中的某处时，相应的表单会被传送到服务器，并加上两个变量 sub_x 和 sub_y。

---

<br>

### 4.4.3	HTTP Cookies

##### 说明

- PHP 支持 HTTP cookies。Cookies 是一种在远端浏览器端存储数据并能追踪或识别再次访问的用户的机制。可以用 setcookie() 函数设定 cookies。Cookies 是 HTTP 信息头中的一部分，因此 SetCookie() 函数必须在向浏览器发送任何输出之前调用。*（对于 header() 函数也有同样的限制）*Cookie 数据会在相应的 cookie 数据数组中可用，例如 `$_COOKIE` 和 `$_REQUEST`。

---

<br>

## 4.5	常量

##### 定义常量

- 在PHP 5.3.0 之后的版本中，可以用两种方法： `define()` 函数，或 `const` 关键字来定义一个常量。
- 函数 define() 允许将常量定义为一个表达式，而 const 关键字有一些限制。

##### 使用 define() 函数定义常量

- `define()` 用于在运行时定义一个常量。

##### 使用 const 关键字定义常量

- 使用 const 关键字定义常量时，PHP 5.6 之前只能包含标量数据（boolean，integer，float 和 string）。
- 从 PHP 5.6 开始，可以将常量定义为一个表达式，也可以定义为一个 array。
- 和使用 define() 来定义常量相反的是，使用 const 关键字定义常量必须处于最顶端的作用区域，因为用此方法是在编译时定义的。这就意味着不能在函数内，循环内以及 if 或 try/catch 语句之内用 const 来定义常量。
- 使用 const 关键字定义的常量总是大小写敏感的，而使用 define() 函数定义的常量可能不区分大小写。

##### 获取常量的值

- 可以简单的通过指定其名字来取得常量的值，如果常量名是动态的，也可以用函数 `constant()` 来获取常量的值。用

   `get_defined_constants()` 可以获得所有已定义的常量列表。

##### 常量和变量的不同

- 常量前面没有美元符号 `$`；
- PHP 5.3 之前，常量只能用 define() 函数定义，而不能通过赋值语句；
- 常量可以不用理会变量的作用域而在任何地方定义和访问；
- 常量一旦定义就不能被重新定义或者取消定义；
- 常量的值只能是标量值。从 PHP 5.6 开始可以用 const 关键字来定义数组常量，从 PHP 7 开始也可以用 define() 函数来定义。你可以在常量标量表达式中使用数组（例如 const FOO = array(1,2,3)[0];），但是要求最终的结果必须是一个允许的类型的值。

---

<br>

# 5	表达式与运算符

## 5.1	表达式在 PHP 中的意义

##### 说明

- 表达式是 PHP 最重要的基石。PHP 是一种面向表达式的语言，在 PHP 中，几乎所写的任何东西都是一个表达式。简单但却最精确的定义一个表达式的方式就是“任何有值的东西”。

---

<br>

## 5.2	运算符的优先级（忽略）

---

<br>

## 5.3	算术运算符（忽略）

---

<br>

## 5.4	赋值运算符（忽略）

---

<br>

## 5.5	位运算符（忽略）

---

<br>

## 5.6	比较运算符

##### 比较运算符

| 例          | 名称                       | 结果                                                         |
| :---------- | :------------------------- | :----------------------------------------------------------- |
| `$a == $b`  | 等于                       | **`true`**，如果类型转换后 `$a` 等于 ​`$b`。                  |
| `$a === $b` | 全等                       | **`true`**，如果 `$a` 等于 ​`$b`，并且它们的类型也相同。      |
| `$a != $b`  | 不等                       | **`true`**，如果类型转换后 `$a` 不等于 `$b`。                |
| `$a <> $b`  | 不等                       | **`true`**，如果类型转换后 `$a` 不等于 `$b`。                |
| `$a !== $b` | 不全等                     | **`true`**，如果 `$a` 不等于 ​`$b`，或者它们的类型不同。      |
| `$a < $b`   | 小与                       | **`true`**，如果 `$a` 严格小于 `$b`。                        |
| `$a > $b`   | 大于                       | **`true`**，如果 `$a` 严格大于 `$b`。                        |
| `$a <= $b`  | 小于等于                   | **`true`**，如果 `$a` 小于或者等于 `$b`。                    |
| `$a >= $b`  | 大于等于                   | **`true`**，如果 `$a` 大于或者等于 `$b`。                    |
| `$a <=> $b` | 太空船运算符（组合比较符） | 当`$a`小于、等于、大于 `$b` 时 分别返回一个小于、等于、大于0的 int 值。 |

##### 不同类型之间的比较

| 运算数 1 类型                | 运算数 2 类型                | 结果                                                         |
| :--------------------------- | :--------------------------- | :----------------------------------------------------------- |
| null 或 string               | string                       | 将 **`null`** 转换为 ""，进行数字或词汇比较                  |
| bool 或 null                 | 任何其它类型                 | 转换为 bool，**`false`** < **`true`**                        |
| object                       | object                       | 内置类可以定义自己的比较，不同类不能比较，相同类和数组同样方式比较属性（PHP 4 中），PHP 5 有其自己的[说明](https://www.php.net/manual/zh/language.oop5.object-comparison.php) |
| string、resource、int、float | string、resource、int、float | 将字符串和资源转换成数字，按普通数学比较                     |
| array                        | array                        | 具有较少成员的数组较小，如果运算数 1 中的键不存在于运算数 2 中则数组无法比较，否则挨个值比较（见下例） |
| object                       | 任何其它类型                 | object 总是更大                                              |
| array                        | 任何其它类型                 | array 总是更大                                               |

##### NULL 合并运算符 

- 当 expr1 为 **`null`**，表达式 `(expr1) ?? (expr2)` 等同于 expr2，否则为 expr1。

- **例**：

  ```php
  <?php
  $action = $_POST['action'] ?? 'default';
  
  // 以上例子等同于于以下 if/else 语句
  if (isset($_POST['action'])) {
      $action = $_POST['action'];
  } else {
      $action = 'default';
  }
  
  ?>
  ```

- 📌**注意**：

  - NULL 合并运算符是一个表达式，产生的是表达式结果，而不是变量。 返回引用变量时需要强调这一点。 在返回引用的函数里无法使用这样的语句：`return $foo ?? $bar;`。

##### 📌不要比较浮点数

- 由于浮点数 `float` 的内部表达方式，不应比较两个浮点数是否相等。

---

<br>

## 5.7	错误控制运算符

##### 说明

- PHP 错误控制运算符：`@`。
- 当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉。

##### 📌@ 运算符只对表达式有效

- 由于 `@` 运算符只对表达式有效，简单的说，如果能从某处得到值，就能在它前面加上 `@` 运算符。
- 例如，可以把 `@` 运算符放在变量，函数和 `include` 调用，常量，等等之前。**不能把它放在函数或类的定义之前，也不能用于条件结构例如 `if` 和 `foreach` 等。**

##### 📌不要滥用 @

目前的“@”错误控制运算符前缀甚至使导致脚本终止的严重错误的错误报告也失效。 如果加上错误控制运算符的表达式中出现了错误，脚本将会不提示任何信息直接在那里终止。

---

<br>

## 5.8	执行运算符

##### 说明

- PHP 执行运算符：反引号  `` ` 。
- PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。
- 使用反引号运算符 `` ` 的效果与函数 `shell_exec()` 相同。
- 📌**注意**：
  - 关闭了 `shell_exec()` 时反引号运算符是无效的。
  - 与其它某些语言不同，**反引号不能在双引号字符串中使用**。

---

<br>

## 5.9	逻辑运算符

##### 逻辑运算符

| 例子        | 名称            | 结果                                                      |
| :---------- | :-------------- | :-------------------------------------------------------- |
| `$a and $b` | And（逻辑与）   | **`true`**，如果 $a 和 $b 都为 **`true`**。               |
| `$a or $b`  | Or（逻辑或）    | **`true`**，如果 $a 或 $b 任一为 **`true`**。             |
| `$a xor $b` | Xor（逻辑异或） | **`true`**，如果 $a 或 $b 任一为 **`true`**，但不同时是。 |
| `! $a`      | Not（逻辑非）   | **`true`**，如果 $a 不为 **`true`**。                     |
| `$a && $b`  | And（逻辑与）   | **`true`**，如果 $a 和 $b 都为 **`true`**。               |
| `$a || $b`  | Or（逻辑或）    | **`true`**，如果 $a 或 $b 任一为 **`true`**。             |

---

<br>

# 6	流程控制

## 6.1	分支

##### 📌elseif 与 else if

- `else if` 可以写成 `elseif`

---

<br>

## 6.2	循环

---

<br>

## 6.3	遍历

##### 说明

- `foreach` 语法结构提供了遍历数组的简单方式。`foreach` 仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。

##### 语法

- **形式一**：

  ```php
  foreach (iterable_expression as $value)
      statement
  ```

- **形式二**：

  ```php
  foreach (iterable_expression as $key => $value)
      statement
  ```

---

<br>

## 6.4	跳转

---

<br>

## 6.5	declare（未完成）

---

<br>

## 6.6	include 与 require 

**说明**

- `include` 语句包含并运行指定文件。`require` 和 `include` 几乎完全一样，除了处理失败的方式不同之外。*（`require` 在出错时产生 `E_COMPILE_ERROR` 级别的错误。换句话说将导致脚本中止而 `include` 只产生警告（`E_WARNING`），脚本会继续运行。）*

##### php 解释器查找被包含文件的过程

- 被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照 `include_path` 指定的目录寻找。
- 如果在 `include_path` 下没找到该文件则 `include` 最后才在调用脚本文件所在的目录和当前工作目录下寻找。
- 如果最后仍未找到文件则 include 结构会发出一条警告；require 会发出一个致命错误。
- 📌**注意**：
  - 如果定义了路径——不管是绝对路径（在 Windows 下以盘符或者 \ 开头，在 Unix/Linux 下以 / 开头）还是当前目录的相对路径（以 . 或者 .. 开头）——include_path 都会被完全忽略。

##### 被包含文件可以获得的作用域范围

- 当一个文件被包含时，其中所包含的代码继承了 include 所在行的变量范围。从该处开始，**调用文件在该行处可用的任何变量在被调用的文件中也都可用**。不过，**所有在包含文件中定义的函数和类都具有全局作用域**。

##### 被包含文件的解析过程

- 当一个文件被包含时，语法解析器在目标文件的开头脱离 PHP 模式并进入 HTML 模式，到文件结尾处恢复。*（因此，目标文件中需要作为 PHP 代码执行的任何代码都必须被包括在有效的 PHP 起始和结束标记之中。）*

##### 通过 URL 指定被包含文件

- 如果 “URL include wrappers” 选项在 PHP 中被激活，可以用 URL*（通过 HTTP 或者其它支持的封装协议）*而不是本地文件来指定要被包含的文件。
- 如果目标服务器将目标文件作为 PHP 代码解释，则可以用适用于 HTTP GET 的 URL 请求字符串来向被包括的文件传递变量。严格的说这和包含一个文件并继承父文件的变量空间并不是一回事；该脚本文件实际上已经在远程服务器上运行了，而本地脚本则包括了其结果。

##### 处理返回值

- 在失败时 include 返回 FALSE 并且发出警告。成功时，除非在包含文件中另外给出了返回值，否则返回 1。
- 可以在被包括的文件中使用 return 语句来终止该文件中程序的执行并返回调用它的脚本。
- 可以像普通函数一样获得 include 调用的返回值。*（不过在包含远程文件时却不行，除非远程文件的输出具有合法的 PHP 开始和结束标记）*
- 可以在标记内定义所需的变量，该变量在文件被包含的位置之后就可用了。
- 因为 include 是一个特殊的语言结构，其参数不需要括号。在比较其返回值时要注意。

##### require_once 与 include_once

- `require_once`/`include_once` 语句和 `require`/`include` 语句完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。

---

<br>

# 7	函数

## 7.1	基本语法

##### 函数的内容

- 任何有效的 PHP 代码都有可能出现在函数内部，甚至包括其它函数和类定义。

##### 函数的定义位置

- 除了两种特殊情况（有条件的函数和函数中的函数），函数无需在调用之前被定义。

##### 有条件的函数

```php
<?php

$makefoo = true;

/* 不能在此处调用foo()函数，因为它还不存在。*/

if ($makefoo) {
  function foo()
  {
    echo "I don't exist until program execution reaches me.\n";
  }
}

/* 现在可以安全调用函数 foo()
   因为 $makefoo 值为真 */
if ($makefoo) foo();

?>
```

##### 函数中的函数

```php
<?php
function foo()
{
  function bar()
  {
    echo "I don't exist until foo() is called.\n";
  }
}

/* 现在还不能调用 bar() 函数，因为它还不存在 */

foo();

/* 现在可以调用 bar() 函数了，因为 foo() 函数
   的执行使得 bar() 函数变为已定义的函数 */

bar();

?>
```

##### 函数的作用域

- PHP 中的所有函数和类都具有全局作用域。*（因此可以函数定义在另一个函数的内部，而在这个函数的外部被调用）*

##### 📌PHP 函数的缺点

- PHP 不支持函数重载，也不可能取消定义或者重定义已声明的函数。

---

<br>

## 7.2	函数的参数与返回值

##### 函数的参数

- 支持可变参数列表
- 支持参数默认值

##### 📌通过引用传递参数 

- 默认情况下，函数参数通过值传递（使在函数内部改变参数的值，并不会改变函数外部的值）。如果希望允许函数修改它的参数值，必须通过引用传递参数。

- 如果想要函数的一个参数总是通过引用传递，可以在函数定义中该参数的前面加上符号 `&`：

- **例**：

  ```php
  <?php
  function add_some_extra(&$string)
  {
      $string .= 'and something extra.';
  }
  $str = 'This is a string, ';
  add_some_extra($str);
  echo $str;    // outputs 'This is a string, and something extra.'
  ?>
  ```

##### 函数的返回值

- 值通过使用可选的返回语句返回。可以返回包括数组和对象的任意类型。返回语句会立即中止函数的运行，并且将控制权交回调用该函数的代码行。

---

<br>

## 7.3	可变函数

##### PHP 可变函数

- PHP 支持可变函数。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。
- 📌**注意**：
  - 可变函数不能用于例如 echo，print，unset()，isset()，empty()，include，require 以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。

---

<br>

## 7.4	匿名函数

##### 什么是匿名函数

- 匿名函数（Anonymous functions），也叫闭包函数（closures），PHP 允许临时创建一个没有指定名称的函数。

##### 匿名函数的作用

- 匿名函数常用作回调函数 callable 参数的值。当然，也有其它应用的情况。

##### 匿名函数的实现方式

- 匿名函数目前是通过 Closure 类来实现的。

- **例**：

  ```php
  <?php
  echo preg_replace_callback('~-([a-z])~', function ($match) {
      return strtoupper($match[1]);
  }, 'hello-world');
  // 输出 helloWorld
  ?>
  ```

##### 匿名函数作为变量的值

- 闭包函数也可以作为变量的值来使用。PHP 会自动把此种表达式转换成内置类 Closure 的对象实例。把一个 closure 对象赋值给一个变量的方式与普通变量赋值的语法是一样的，最后也要加上分号 `;`（因为此时整个结构构成了一个表达式）。

- **例**：

  ```php
  <?php
  $greet = function($name)
  {
      printf("Hello %s\r\n", $name);
  };
  
  $greet('World');
  $greet('PHP');
  ?>
  ```

##### 从父作用域继承变量

- **什么是父作用域**：闭包的父作用域是定义该闭包的函数（不一定是调用它的函数）。

- 匿名函数可以从父作用域中继承变量。 任何此类变量都应该用 `use` 语言结构传递进去。（ PHP 7.1 起，不能传入下列变量： superglobals、 $this 或者和参数重名的变量）

- **例**：

  ```php
  <?php
  $message = 'hello';
  
  // 没有 "use"
  $example = function () {
      var_dump($message);
  };
  $example();
  
  // 继承 $message
  $example = function () use ($message) {
      var_dump($message);
  };
  $example();
  
  // Inherited variable's value is from when the function
  // is defined, not when called
  $message = 'world';
  $example();
  
  // Reset message
  $message = 'hello';
  
  // Inherit by-reference
  $example = function () use (&$message) {
      var_dump($message);
  };
  $example();
  
  // The changed value in the parent scope
  // is reflected inside the function call
  $message = 'world';
  $example();
  
  // Closures can also accept regular arguments
  $example = function ($arg) use ($message) {
      var_dump($arg . ' ' . $message);
  };
  $example("hello");
  ?>
  ```

##### 静态匿名函数 

- 匿名函数允许被定义为静态化。这样可以防止当前类自动绑定到它们身上，对象在运行时也可能不会被绑定到它们上面。

- **例**：

  ```php
  <?php
  
  class Foo
  {
      function __construct()
      {
          $func = static function() {
              var_dump($this);
          };
          $func();
      }
  };
  new Foo();
  
  ?>
  ```

---

<br>

## 7.5	箭头函数

##### 什么是箭头函数

- 箭头函数是 PHP 7.4 的新语法，是一种更简洁的匿名函数写法。

**箭头函数的实现原理**

- 匿名函数和箭头函数都是 Closure 类的实现。

##### 箭头函数的基本语法

```php
fn (argument_list) => expr
```

##### 箭头函数与匿名函数的区别

- 箭头函数支持与匿名函数相同的功能，只是其父作用域的变量总是自动的。当表达式中使用的变量是在父作用域中定义的，它将被隐式地按值捕获。

---

<br>

# 8	类和对象

---

<br>

# 9	命名空间

---

<br>

# 10	 错误和异常

---

<br>

# 11	注解

---

<br>

# 附录

##### 最后编辑时间

- 2021/03/04

##### 环境

- php-7.4.15-Win32-vc15-x64
- PhpStorm 2020.3.2

##### 参考资料

- [PHP 手册](https://www.php.net/manual/zh/index.php)

##### 相关资料

- 

##### 脚注

[^脚本语言]: 又称扩建的语言，或动态语言，是一种编程语言，用来控制软件应用程序，脚本通常以文本*（如ASCII)保存，只在被调用时进行解释或编译。

##### 代码链接

[1]: 

##### 锚点

[](#1)

##### 质疑

[^!1]: 

##### 疑问

[^?1]: 是否是特定类型的对象，转换为 object 不会出现问题？

