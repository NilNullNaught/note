# 1	面向对象概述

## 1.1	面向对象相关的概念

##### 面向对象的程序设计

- 程序员必须要在 **解决方案空间**（ 机器模型，对实际问题进行建模的地方，如计算机）和 **问题空间**（实际解决的问题模型，即实际解决的问题模型）之间建立起一种关联。这个过程既费精力，又脱离编程语言本身的范畴。这使得程序代码很难编写，维护代价高昂。

  面向对象的程序设计在此基础上跨出了一大步，程序员可利用一些工具表达“问题空间”内的元素。由于这种表达非常具有普遍性，所以不必受限于特定类型的问题。我们将问题空间中的元素以及它们在解决方案空间的表示称作“对象”（Object）。

<br>

##### Grady Booch[^Grady Booch]对对象简洁地描述

- 一个对象具有自己的状态，行为和标识。这意味着对象有自己的内部数据(提供状态)、方法 (产生行为)，并彼此区分（每个对象在内存中都有唯一的地址）。

<br>

##### “纯粹”的面向对象程序设计方法

- ###### 万物皆对象

  你可以将对象想象成一种特殊的变量。它存储数据，但可以在你对其“发出请求”时执行本身的操作。理论上讲，你总是可以从要解决的问题身上抽象出概念性的组件，然后在程序中将其表示为一个对象。

- ###### 程序是一组对象，通过消息传递来告知彼此该做什么

  要请求调用一个对象的方法，你需要向该对象发送消息。

- ###### 每个对象都有自己的存储空间，可容纳其他对象

  或者说，通过封装现有对象，可制作出新型对象。所以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。

- ###### 每个对象都有一种类型

  根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class）是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。

- ###### 同一类所有对象都能接收相同的消息

  例如，由于类型为“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收发送给"形状”的消息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括“圆”。这一特性称为对象的 “可替换性”，是 OOP 最重要的概念之一。

<br>

##### “万物皆对象”的矛盾

- 固执地要求所有东西都是一个对象（特别是一直到最底层级别）是一种设计错误；但是，完全逃避“对象”的概念似乎同样太过苛刻。

<br>

##### 类和对象

- 所有对象都是唯一的，但同时也是具有相同的特性和行为的对象所归属的类的一部分。

<br>

##### 类和接口

- 每个对象仅能接受特定的请求。我们向对象发出的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。**“类型”与“接口”的对应关系是面向对象程序设计的基础**。

<br>

##### 对象的设计原则

- 在良好的面向对象设计中，**每个对象功能单一且高效**。这样的程序设计可以提高我们代码的复用性，同时也方便别人阅读和理解我们的代码。只有让人知道你提供什么服务，别人才能更好地将其应用到其他模块或程序中。

<br>

---

<div STYLE="page-break-after: always;"><br></div>

## 1.2	对象创建与生命周期

我们在使用对象时要注意的一个关键问题就是对象的创建和销毁方式。每个对象的生存都需要资源，尤其是内存。为了资源的重复利用，当对象不再被使用时，我们应该及时释放资源，清理内存。

---

<div STYLE="page-break-after: always;"><br></div>

# 2	Java 面向对象基础

## 2.1	类的声明

---

<div STYLE="page-break-after: always;"><br></div>

## 2.2	构造器对象的初始化

---

<div STYLE="page-break-after: always;"><br></div>

## 2.3	this 关键字

---

<div STYLE="page-break-after: always;"><br></div>

## 2.4	对象回收

### 2.4.1	垃圾回收机制

---

<div STYLE="page-break-after: always;"><br></div>

### 2.4.2	finalize()

---

<div STYLE="page-break-after: always;"><br></div>

### 2.4.3	终结条件

---

<div STYLE="page-break-after: always;"><br></div>

## 2.5	可变参数列表与其实现原理

---

<div STYLE="page-break-after: always;"><br></div>

# 3	封装

## 3.0

##### 为什么需要封装

- ###### 研发编程与应用编程

  我们可以把编程的侧重领域划分为研发和应用。应用程序员调用研发程序员构建的基础工具类来做快速开发。研发程序员开发一个工具类，该工具类仅向应用程序员公开必要的内容，并隐藏内部实现的细节。这样可以有效地避免该工具类被错误的使用和更改，从而减少程序出错的可能。彼此职责划分清晰，相互协作。当应用程序员调用研发程序员开发的工具类时，双方建立了关系。应用程序员通过使用现成的工具类组装应用程序或者构建更大的工具库。

- ###### 使用封装的原因

  **如果工具类的创建者将类的内部所有信息都公开给调用者，那么有些使用规则就不容易被遵守**。因为前者无法保证后者是否会按照正确的规则来使用，甚至是改变该工具类。只有设定访问控制，才能从根本上阻止这种情况的发生。

<br>

---

<div STYLE="page-break-after: always;"><br></div>

## 3.1	访问权限

##### 使用访问控制的原因

1. 让应用程序员不要触摸他们不应该触摸的部分。（请注意，这也是一个哲学决策。部分编程语言认为如果程序员有需要，则应该让他们访问细节部分。）；
2. 使类库的创建者（研发程序员）在不影响后者使用的情况下完善更新工具库。例如，我们开发了一个功能简单的工具类，后来发现可以通过优化代码来提高执行速度。假如工具类的接口和实现部分明确分开并受到保护，那我们就可以轻松地完成改造。

<br>

##### 访问权限控制符

- ###### 说明

  Java 有三个显式关键字来设置类中的访问权限：`public`（公开），`private`（私有）和`protected`（受保护）<font size=1>（除此之外还有默认权限 default）</font>。这些访问修饰符决定了谁能使用它们修饰的方法、变量或类。

- ###### public

  `public`（公开）表示任何人都可以访问和使用该元素；

- ###### private

  `private`（私有）除了类本身和类内部的方法，外界无法直接访问该元素。`private` 是类和调用者之间的屏障。任何试图访问私有成员的行为都会报编译时错误；

- ###### protected

  `protected`（受保护）类似于 `private`，区别是子类（下一节就会引入继承的概念）可以访问 `protected` 的成员，但不能访问 `private` 成员；

- ###### default

  `default`（默认）如果你不使用前面的三者，默认就是 `default` 访问权限。`default` 被称为包访问，因为该权限下的资源可以被同一包（库组件）中其他类的成员访问。

---

<div STYLE="page-break-after: always;"><br></div>

## 3.1	访问权限



---

<div STYLE="page-break-after: always;"><br></div>

# 4	复用与继承

## 4.0

##### 面向对象编程的复用性

- 代码和设计方案的复用性是面向对象程序设计的优点之一。我们可以通过重复使用某个类的对象来达到这种复用性。同时，我们也可以将一个类的对象作为另一个类的成员变量使用。新的类可以是由任意数量和任意类型的其他对象构成。

<br>

##### 通过继承复用代码

- 在创建了一个类之后，我们可以对其进行“克隆”，使另一个新类与其具有相似的功能，再根据情况进行添加和修改。“继承”正是针对这个目标而设计的。

  但继承并不完全等价于克隆。在继承过程中，若原始类（正式名称叫作基类、超类或父类）发生了变化，修改过的“克隆”类（正式名称叫作继承类或者子类）也会反映出这种变化。

<br>

##### 组合与聚合

- ###### 说明

  组合和聚合都属于关联关系的一种，只是额外具有 **整体-部分** 的意义。

- ###### 组合

  组合（Composition）经常用来表示“拥有”关系（has-a relationship）。例如，“汽车拥有引擎”。

- ###### 聚合

  聚合（Aggregation），**动态的组合**。

- ###### 区分组合与聚合

  需要根据实际的业务需求来判断是聚合还是组合。可能相同超类和子类，在不同的业务场景，关联关系会发生变化。**只看代码是无法区分聚合和组合的**，具体是哪一种关系，只能从语义级别来区分。聚合关系中，整件不会拥有部件的生命周期，所以整件删除时，部件不会被删除。再者，多个整件可以共享同一个部件。组合关系中，整件拥有部件的生命周期，所以整件删除时，部件一定会跟着删除。而且，多个整件不可以同时共享同一个部件。这个区别可以用来区分某个关联关系到底是组合还是聚合。**两个类生命周期不同步，则是聚合关系，生命周期同步就是组合关系。**

<br>

##### 创建新类时，优先考虑通过组合而不是继承复用代码

- 在面向对象编程中经常重点强调“继承”。在新手程序员的印象里，或许先入为主地认为“继承应当随处可见”。沿着这种思路产生的程序设计通常拙劣又复杂。相反，在创建新类时首先要考虑“组合”，因为它更简单灵活，而且设计更加清晰。

<br>

---

<div STYLE="page-break-after: always;"><br></div>

## 4.1	is-a 与 is-like-a

##### is-a

- 如果继承只覆盖基类的方法，基类和派生类就是相同的类型了，因为它们具有相同的接口。这会造成，你可以用一个派生类对象完全替代基类对象，这叫作"纯粹替代"，也经常被称作"替代原则"。

  在某种意义上，这是一种处理继承的理想方式。我们经常把这种基类和派生类的关系称为是一个（is-a）关系，因为可以说"圆是一个形状"。

<br>

##### is-like-a

- 有时你在派生类添加了新的接口元素，从而扩展接口。虽然新类型仍然可以替代基类，但是这种替代不完美，原因在于基类无法访问新添加的方法。这种关系称为像是一个(is-like-a)关系。新类型不但拥有旧类型的接口，而且包含其他方法，所以不能说新旧类型完全相同。

<br>

---

<div STYLE="page-break-after: always;"><br></div>

## 4.2	方法覆盖

---

<div STYLE="page-break-after: always;"><br></div>

## 4.3	单继承结构

---

<div STYLE="page-break-after: always;"><br></div>

# 4	多态

## 4.0（未完成，参考 On Java 9 第一章 多态一节）

##### Java 实现多态的原理

- ###### 后期绑定



---

<div STYLE="page-break-after: always;"><br></div>

## 4.1	向上转型

---



# 7	抽象类与接口

---

<div STYLE="page-break-after: always;"><br></div>

# 9	内部类

---

<div STYLE="page-break-after: always;"><br></div>

# 附录

##### 最后编辑时间

- 0000/00/00

##### 环境

- 

##### 参考资料

- 

##### 相关资料

- 

##### 代码链接

[1]:

##### 锚点

[](#1) 

##### 脚注

[^Grady Booch]: **Grady Booch** (born February 27, 1955) is an American [software engineer](https://en.wikipedia.org/wiki/Software_engineer), best known for developing the [Unified Modeling Language](https://en.wikipedia.org/wiki/Unified_Modeling_Language) (UML) with [Ivar Jacobson](https://en.wikipedia.org/wiki/Ivar_Jacobson) and [James Rumbaugh](https://en.wikipedia.org/wiki/James_Rumbaugh). He is recognized internationally for his innovative work in software architecture, software engineering, and [collaborative development environments](https://en.wikipedia.org/wiki/Collaborative_development_environment). ↩

